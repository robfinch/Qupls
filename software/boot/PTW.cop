;===============================================================================
;        __
;   \\__/ o\    (C) 2026  Robert Finch, Waterloo
;    \  __ /    All rights reserved.
;     \/_;     robfinch<remove>@finitron.ca
;       ||
;
;
; BSD 3-Clause License
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;
; 1. Redistributions of source code must retain the above copyright notice, this
;    list of conditions and the following disclaimer.
;
; 2. Redistributions in binary form must reproduce the above copyright notice,
;    this list of conditions and the following disclaimer in the documentation
;    and/or other materials provided with the distribution.
;
; 3. Neither the name of the copyright holder nor the names of its
;    contributors may be used to endorse or pnext_irte products derived from
;    this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;===============================================================================
; wait - turns paging on, waits for a miss, then turns paging off
; load config - loads registers r1 to r6 with the TLB config info
; calc_pte_index - calculates the index portion of the PTE address
; calc_pte_adr	- calculates the PTE address
;
	.set gr_cmdq,$0xFE000DC0

.macro macRandCoord n
	loadi64 %r2,$0xFE007800
	load %r2,[%r2]
	and %r2,%r2,%r2,$255
	shl %r2,%r2,%r0,$16
	loadi64 %r1,\n
	or %r1,%r1,%r2,$0
	store %r1,[%r7]
.endm

.macro macRandColor n
	loadi64 %r2,$0xFE007800
	load %r2,[%r2]
	loadi64 %r1,$0x32767
	and %r2,%r2,%r1,$-1
	loadi64 %r1,\n
	or %r1,%r1,%r2,$0
	store %r1,[%r7]
.endm

.macro macWaitForQueue n
.0007\@:
	loadi64 %r7,$0xFE000DC8		; status reg
	load %r7,[%r7]						; get status
	loadi %r11,\n							; number of entries we want available
	jlt %r7,%r11,.0007\@
.endm

	.section .bram
	.org 0x0000
start:
	call initialize	
	jump idle_state

; TLB miss ISR
; Uses only the first eight registers which are automatically swapped with the
; GPRs.
;
; Register usage:
; r1 = miss address
;	r2 = current page table base address
; r3 = log2 page size (13)
;	r4 = current page table level being processed
; r5 = miss asid
; r6 = current invalidation count
; r7 = temp: index into table / address of PTE
; r8 = TLB select, base I/O address of TLB registers

	.org 0x0010
tlb_miss_isr:
	loadi %r8,0							; r8 = largest page size TLB index
; Walk all TLBs from largest page size to smallest
tlb_miss1:
	load_config	%r8					; load registers r1 to r6 with config
	jeqz %r4,read_level0		; starting with a single level page table?

; Walk all the levels of the page table until a page fault occurs or the PTE
; is found.
read_leveln:
	calc_index %r7,%r4
	calc_adr %r7,%r2,%r7
	load %r2,[%r7]					; r2 = fetch PTE
	jgez %r2,page_fault			; check for valid page
	shl %r7,%r2,$10					; get bit 53 status
;	jltz %r7,read_level0a		; if a shortcut page...
	and64 %r2,%r2,%r2,$0x7fffffffff		; extract PPN
	shl %r2,%r2,%r3					; r2 = address of page table
	djnez %r4,read_leveln		; go down a level

read_level0:
	calc_index %r7,%r4
	calc_adr %r4,%r2,%r7
	load %r3,[%r4]					; r3 = fetch PTE
	jgez %r3,page_fault			; check for valid page
read_level0a:
	build_vpn %r4						; r4 = TLBE high
	shl %r8,%r8,%r0,$3			; r8 = index to base address table
	load %r8,tlb_regs_adr[%r8]	; r8 = base address of page table
	shr %r5,%r8,%r0,$24			; r5 = mask for configured number of TLB entries
	shr %r5,%r5,%r0,$24
	and %r1,%r7,%r5,$-1			; r1 = read_adr masked for N TLB entries
;	loadi %r2,$3						; r2 = way to set (3 for LRU) (the way is ignored on a set)
;	call set_tlbe						; inline set
	store %r3,0x00[%r8]			; set low order TLBE
	store %r4,0x08[%r8]			; set high order TLBE
	build_entry_no %r5,%r1,%r0,$31
	store %r5,0x20[%r8]			; set entry number field, causes update
	ret $0xFF								; return and restore registers

; Just becasue there is a page fault on a table does not mean that some other
; table of smaller pages does not have a translation. Check the next smallest
; table. When we run out of TLBs to check, then page fault.
page_fault:
	jeqz %r8,page_fault1
	djnez %r8,tlb_miss1
page_fault1:
	bmset %r0,signal[%r0]		; set page fault output
	ret $0xFF								; return and restore registers

; Parameters:
;		r1 entry number
;		r2 = way to get
;		r8 = base I/O address of TLB control regs
; Returns:
;		r1 = TLBE low (PTE)
;		r2 = TLBE high

get_tlbe:
	build_entry_no %r3,%r1,%r0,$30
	store %r3,0x20[%r8]			; set entry number field
	nop											; wait a bit
	load %r1,0x00[%r8]			; get low order TLBE
	load %r2,0x08[%r8]			; get high order TLBE
	ret $0xFC								; do not restore r1,r2

; Parameters:
;		r1 = entry number
;		r2 = way to get
;		r3 = TLBE low (PTE)
;		r4 = TLBE high
;		r8 = base I/O address of TLB control regs
; Returns:

set_tlbe:
	store %r3,0x00[%r8]		; set low order TLBE
	store %r4,0x08[%r8]		; set high order TLBE
	build_entry_no %r5,%r1,%r0,$31
	store %r5,0x20[%r8]		; set entry number field
	ret $0xFF							; restore registers

;

initialize:
	call ResetPAM
	call ClearScreen
	call DrawCharacters
	; fall through into idle state

; Go to low power wait mode.
; Wait for either an interrupt or the posting of a command to the command
; address. Capture the command in r7.
; If there was an interrupt, then the interrupt will return to the WAIT
; instruction, not the next line of code. So, WAIT forms an interrupt
; waiting loop all by itself. No need to loop back.
; On the other hand, if there is a command posted WAIT will transfer
; to the next instruction so the command can be processed.

idle_state:
	wait %r7,cmd_cmd					; wait for a miss signal or command

process_cmd:
	loadi %r1,$7							; number of commands
	jge %r7,%r1,.bad_cmd			; return error if command out of range
	shl %r7,%r7,%r0,$3				; command to table index
	load %r7,CMD_table[%r7]		; get command function address
	call [%r7]								; go exeute the command
	store %r1,cmd_stat				; set status (error number)
	loadi %r1,1
	bmset %r0,signal[%r1]			; trigger the command done signal (interrupt?)
	jump idle_state						; go back for the next command
.bad_cmd:
	store $1,cmd_stat					; set 'bad' command status in command RAM area
	loadi %r1,1
	bmset %r0,signal[%r1]			; trigger the command done signal (interrupt?)
	jump idle_state						; go back for the next command

; Get a TLB entry
;
; Parameters:
;		cmd_arg1 = entry number in bits 0-15, TLB number in bits 24-31 
; Returns:
;		cmd_arg2 = TLBE low
;		cmd_arg3 = TLBE high
;		cmd_stat = 0 (okay)

cmd_get_tlbe:
	load %r1,cmd_arg1						; r1 = entry number and way
	shr %r8,%r1,%r0,$24					; get TLB number
	shl %r8,%r8,%r0,$3					; r8 = word index
	load %r8,tlb_regs_adr[%r8]	; r8 = base address of TLB regset
	shr %r2,%r8,%r0,$24					; r2 = number of TLB entries-1
	shr %r2,%r8,%r0,$24
	and %r1,%r1,%r2							; r1 = entry number masked to limit
	call get_tlbe
	store %r1,cmd_arg2					; set TLBE in arg area
	store %r2,cmd_arg3
cmd_ok:
	move %r1,%r0
	ret $0xFE

; Set a TLB entry
;
; Parameters:
;		cmd_arg1 = entry number in bits 0-15, TLB number in bits 24-31 
;		cmd_arg2 = TLBE low
;		cmd_arg3 = TLBE high
; Returns:
;		cmd_stat = 0 (okay)

cmd_set_tlbe:
	load %r1,cmd_arg1						; arg1 = entry number
	shr %r8,%r1,%r0,$24					; get TLB number
	shl %r8,%r8,%r0,$3					; r8 = word index
	load %r8,tlb_regs_adr[%r8]	; r8 = base address of TLB regset
	shr %r2,%r8,%r0,$24					; r2 = number of TLB entries-1
	shr %r2,%r2,%r0,$24
	and %r1,%r1,%r2							; r1 = entry number masked to limit
	xor %r2,%r2,%r2							; r2 = way = 0 (ignored on a set)
	load %r3,cmd_arg2						; get TLBE arg into r3,r4
	load %r4,cmd_arg3
	call set_tlbe
	jump cmd_ok

	.org 0x0200
frame_isr:
	ret $0xFF
	nop

; Clear PAM memory
ResetPAM:
	storei $131072,PAM_avail
	store %r0,PAM_index
	ret $0xff

;	call RandomizeScreen

;	loadi64 %r3,$0x00100000
;	loadi %r5,$300	
;	loadi64 %r2,$0x03e003e003e003e0
.0004:
;	store %r2,[%r3]
;	add %r3,%r3,%r0,$802
;	djnez %r5,.0004
plot25k:
;	call PlotRandomPoints
;	call DrawRandomRectangles
;	call DrawRandomTriangles
;	call DrawDownDiagonal
	
; Clear screen
ClearScreen:
	loadi64 %r1,$30000
;	loadi64 %r2,$0x7c007c007c007c00		; RED
	loadi64 %r3,$0x00100000
	loadi64 %r2,$0x7FCE7FCE7FCE7FCE		; RED
.0001:
	store %r2,[%r3]	; Pale yellow
	add %r3,%r3,%r0,$8
	djnez %r1,.0001
	ret $0xff

	; Randomize screen
RandomizeScreen:
	loadi64 %r1,$120000
	loadi64 %r3,$0x00100000
.0010:
	loadi64 %r2,$0xFE007800	; get random number
	load %r2,[%r2]
	storew %r2,[%r3]				; store as pixel
	add %r3,%r3,%r0,$2			; advance to next pixel
	djnez %r1,.0010
	ret $0xff

PlotRandomPoints:
	loadi64 %r7,$0xFE000DC0		; graphics command queue address

;	loadi64 %r2,$0x0c000003e0	; set green pencolor
;	store %r2,[%r7]
	loadi %r5,$15000					; repeat 25000 times
.0007:
	macWaitForQueue $5
	
	loadi64 %r7,$0xFE000DC0		; graphics command queue address
	; set random X0
	macRandCoord $0x1000000000
	; set random Y0
	macRandCoord $0x1100000000
	; set random pen color
	macRandColor $0x0c00000000
	loadi64 %r6,$0x0100000010	; plot command copy
	store %r6,[%r7]						; queue command
	djnez %r5,.0007
	ret $0xff

DrawDownDiagonal:
	loadi %r3,$0x1000000000
	loadi %r4,$0x1100000000
	loadi %r5,$300
	loadi64 %r1,$0x10000	; increment
.0002:
	loadi %r10,$1000
	macWaitForQueue $4
	store %r3,[%r7]
	store %r4,[%r7]
	store %r6,[%r7]
	add %r3,%r3,%r1,$0	; increment x0
	add %r4,%r4,%r1,$0	; increment y0
	djnez %r5,.0002
	ret $0xff

DrawRandomRectangles:
	loadi %r5,$3000
.0008:
	; Check if previous blit was done
	loadi64 %r9,$0xFE000D98		; blt control
	load %r2,[%r9]
	shr %r2,%r2,%r0,$13				; bit 13
	and %r2,%r2,%r2,$1				; =1?
	jeqz %r2,.0008						; go back if not done
	loadi64 %r7,$0xFE000DC0		; graphics command queue address
	macWaitForQueue $6
	; random fill color
	macRandColor $0x0d00000000
	; set random X0
	macRandCoord $0x1000000000
	; set random Y0
	macRandCoord $0x1100000000
	; set random X1
	macRandCoord $0x1300000000
	; set random Y1
	macRandCoord $0x1400000000
	loadi64 %r1,$0x0300000010		; fillrect
	store %r1,[%r7]
	djnez %r5,.0008
	ret $0xff

DrawRandomTriangles:
	loadi %r5,$1000
.0006:
	loadi64 %r7,$0xFE000DC0		; graphics command queue address
	macWaitForQueue $8
	loadi %r10,$10000
	; set random X0
	macRandCoord $0x1000000000
	; set random Y0
	macRandCoord $0x1100000000
	; set random X1
	macRandCoord $0x1300000000
	; set random Y1
	macRandCoord $0x1400000000
	; set random X2
	macRandCoord $0x1600000000
	; set random Y2
	macRandCoord $0x1700000000
	; set random color
	macRandColor $0x0d00000000	; fill color
	loadi64 %r1,$0x0600000010		; draw triangle
	store %r1,[%r7]
	djnez %r5,.0006
	ret $0xff

; Draw characters on screen.
DrawCharacters:
	loadi64 %r7,$0xFE000DC0		; graphics command queue address
	; set random pen color
	macRandColor $0x0c00000000
	loadi64 %r3,$0x1000400000		; x0 = 64
	loadi64 %r4,$0x1100280000		; y0 = 40
	store %r4,[%r7]
	loadi %r5,$32
	loadi64 %r1,$0x90000	; increment
	loadi64 %r2,$0x0d00007FFF	; set transparent fill color
	store %r2,[%r7]
	loadi %r2,$0x20
.0005:
	loadi64 %r7,$0xFE000DC0		; graphics command queue address
	macWaitForQueue $3
	loadi64 %r7,$0xFE000DC0		; graphics command queue address
	store %r3,[%r7]						; set X position
	store %r2,[%r7]						; store character
	add %r2,%r2,%r0,$1				; next character
	add %r3,%r3,%r1,$0				; increment x0
	djnez %r5,.0005
	ret $0xff

; Delay a little bit.
; Parameters:
;		r10 = amount of delay
; Returns:
;		none

delay:
	move %r1,%r10
.0001:
	djnez %r1,.0001
	ret $0xFF

; Allocate a page of memory.
; Sets the PAM bit for the page of memory allocated.
;
; Parameters:
;		none
; Returns:
;		cmd_arg1 = page number, -1 if out of memory
;		cmd_stat = 0 (okay) 2 = out of memory

alloc_page:
	loadi %r4,$131072					; number of bits in PAM
	move %r2,%r4							; r4 = max bit
	loadi %r1,PAM_index
.0001:
	bmset %r2,PAM[%r1]				; set PAM bit and return previous setting
	jnez %r2,.0002						; was bit already set?
	load %r2,PAM_avail				; derement PAM available
	add %r2,%r2,%r0,$-1
	store %r2,PAM_avail
	store %r1,PAM_index				; update index for next time
	store %r1,cmd_arg1				; save page number in arg area
	jump cmd_ok								; signal main CPU page selection is ready
.0002:
	add %r1,%r1,%r0,$1				; set up to check next bit bnumber
	jlt %r1,%r4,.0003
	xor %r1,%r1,%r1						; r1 = index zero
.0003:
	djnez %r4,.0001
	; Here the entire bitmap was searched and no free page was found.
	; Report out-of-memory condition
	store $-1,cmd_arg1
	loadi %r1,$2							; 'out-of-memory' error
	ret $0xFE

; Free a page of memory
; Parameters:
;		cmd_arg1 = page number to free
; Returns:
;		cmd_stat = 0 (okay)

free_page:
	loadi %r4,$131072					; number of bits in PAM
	load %r1,cmd_arg1					; get page number to free
	jge %r1,%r4,cmd_ok				; ignore bad request
	bmclr %r1,PAM[%r1]				; clear the bit in the PAM
	load %r4,PAM_avail
	add %r4,%r4,%r1,$0				; increment pages available by free status
	store %r4,PAM_avail
	jump cmd_ok

; Get available page count
; Parameters:
;		none
; Returns:
;		cmd_arg1 = available page count
;		cmd_stat = 0 (okay)

get_free_page_count:
	load %r1,PAM_avail
	store %r1,cmd_arg1
	jmp cmd_ok

; Flush the TLB
; It can take a few cycles to flush the TLB, for example 512x4=2048 cycles.
; So that the main CPU is able to proceed, flushing is turned on and off
; periodically. Otherwise the TLB is disabled while flushing.
flush_all:
	loadi %r2,$0							; r2 = asid = 0
flush1:											; entry point for flush by asid
	flush %r0,%r2,$3					; trigger a flush operation
	loadi %r1,$32							; wait a few cycles
.0001:
	djnez %r1,.0001
	flush %r3,%r2,$0					; turn flush off to allow translations
	jltz %r3,cmd_ok						; was the flush done?
	loadi %r1,$32							; wait a few cycles
.0002:
	djnez %r1,.0002
	flush %r3,%r2,$1					; turn flush on to allow a few flushes
	jgtz %r3,.0001
	jump cmd_ok

; Flush TLB of a specific ASID
flush_asid:
	load %r2,cmd_arg1
	jump flush1

	.align 3
CMD_table:
	.2byte flush_all
	.2byte 0,0,0
	.2byte flush_asid
	.2byte 0,0,0
	.2byte cmd_get_tlbe
	.2byte 0,0,0
	.2byte cmd_set_tlbe
	.2byte 0,0,0
	.2byte alloc_page
	.2byte 0,0,0
	.2byte free_page
	.2byte 0,0,0
	.2byte get_free_page_count
	.2byte 0,0,0

	; Location of TLB registers for each TLB ordered from TLBs
	; with the largest page sizes first.
	; Only the lower 48-bits are used.
	; The number of TLB entries-1 is stuffed in the upper 16 bits
tlb_regs_adr:
	.8byte 	0x01FFFFFFFFF40000	; smallest page size TLB
;	.8byte	0x007FFFFFFFF44000
;	.8byte	0x007FFFFFFFF48000

	; PAM area
	.org 0x3000
PAM:
	.rept 2048
	.8byte	0
	.endr
	; Current index into the PAM
	; 0x4000
PAM_index:
	.8byte	0x0000
PAM_avail:
	.8byte	131072

	.org 0x7D00
clear_page_fault:
	.8byte 0

	.org 0x7E00
pgtbl_info:
	.rept 8
	.8byte 0
	.8byte 0
	.8byte 0
	.8byte 0
	.endr
	.org 0x7F00
miss_info:
	.rept 8
	.8byte 0	; miss address
	.8byte 0	; miss asid
	.endr
	; 0x7F80
cmd_cmd:
	.8byte 0
cmd_arg1:
	.8byte 0
cmd_arg2:
	.8byte 0
cmd_arg3:
	.8byte 0
cmd_stat:
	.8byte 0
	; 7FC0

	; The last word of memory
	; Special signal memory location, a write to here by the co-processor updates
	; the signaling I/O ports as well as the RAM
	.org 0x7FF8
signal:
	.8byte 0
