;===============================================================================
;        __
;   \\__/ o\    (C) 2026  Robert Finch, Waterloo
;    \  __ /    All rights reserved.
;     \/_;     robfinch<remove>@finitron.ca
;       ||
;
;
; BSD 3-Clause License
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;
; 1. Redistributions of source code must retain the above copyright notice, this
;    list of conditions and the following disclaimer.
;
; 2. Redistributions in binary form must reproduce the above copyright notice,
;    this list of conditions and the following disclaimer in the documentation
;    and/or other materials provided with the distribution.
;
; 3. Neither the name of the copyright holder nor the names of its
;    contributors may be used to endorse or pnext_irte products derived from
;    this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;===============================================================================
; wait - turns paging on, waits for a miss, then turns paging off
; load config - loads registers r1 to r6 with the TLB config info
; calc_pte_index - calculates the index portion of the PTE address
; calc_pte_adr	- calculates the PTE address
;
	.set cmd_adr,0x7E00
	.set cmd_arg1,0x7E08
	.set cmd_stat,0x7E10
	.set cmd_resp,0x7E18
	.set entryno,0x7F00
	.set tlbeL,0x7F10
	.set tlbeH,0x7F18
	.set page_fault_flag,0x7F20
	.set sig,0x7F28
	; the mask for the number of TLB entries is stored in the upper 16 bits
	; of the base address value. The hardware does not recognize more than
	; a 48-bit physical address space (or 32 bits for the test system).
	.set tlb_base_adr,0x01FFFFFFFFF40000
	.set tlb2_base_adr,0x007FFFFFFFF44000
	.set tlb_base_adr_reg,0x7F80
	.set PAM,0x4000
	.set PAM_avail,0x3FF8

	.text
	.org 0x0000
start:
	store $131072,PAM_avail
	jump idle_state

; TLB miss ISR
; Uses only the first eight registers which are automatically swapped with the
; GPRs.
;
; Register usage:
; r1 = miss address
;	r2 = current page table base address
; r3 = log2 page size (13)
;	r4 = current page table level being processed
; r5 = miss asid
; r6 = current invalidation count
; r7 = temp: index into table / address of PTE
; r8 = TLB select, base I/O address of TLB registers

	.org 0x0010
tlb_miss_isr:
	loadi %r8,0							; r8 = largest page size TLB index
; Walk all TLBs from largest page size to smallest
tlb_miss1:
	load_config	%r8					; load registers r1 to r6 with config
	jeqz %r4,read_level0		; starting with a single level page table?

; Walk all the levels of the page table until a page fault occurs or the PTE
; is found.
read_leveln:
	calc_index %r7,%r4
	calc_adr %r7,%r2,%r7
	load %r2,[%r7]					; r2 = fetch PTE
	jgez %r2,page_fault			; check for valid page
	shl %r7,%r2,$10					; get bit 53 status
;	jltz %r7,read_level0a		; if a shortcut page...
	and64 %r2,%r2,%r2,$0x7fffffffff		; extract PPN
	shl %r2,%r2,%r3					; r2 = address of page table
	djnez %r4,read_leveln		; go down a level

read_level0:
	calc_index %r7,%r4
	calc_adr %r4,%r2,%r7
	load %r3,[%r4]					; r3 = fetch PTE
	jgez %r3,page_fault			; check for valid page
read_level0a:
	build_vpn %r4						; r4 = TLBE high
	shl %r8,%r8,%r0,$3			; r8 = index to base address table
	load %r8,tlb_regs_adr[%r8]	; r8 = base address of page table
	shr %r5,%r8,%r0,$24			; r5 = mask for configured number of TLB entries
	shr %r5,%r5,%r0,$24
	and %r1,%r7,%r5,$-1			; r1 = read_adr masked for N TLB entries
;	loadi %r2,$3						; r2 = way to set (3 for LRU) (the way is ignored on a set)
;	call set_tlbe						; inline set
	store %r3,0x00[%r8]			; set low order TLBE
	store %r4,0x08[%r8]			; set high order TLBE
	build_entry_no %r5,%r1,%r0,$31
	store %r5,0x20[%r8]			; set entry number field, causes update
	ret $0xFF								; return and restore registers

; Just becasue there is a page fault on a table does not mean that some other
; table of smaller pages does not have a translation. Check the next smallest
; table. When we run out of TLBs to check, then page fault.
page_fault:
	jeqz %r8,page_fault1
	djnez %r8,tlb_miss1
page_fault1:
	store $1,page_fault_flag
	ret $0xFF								; return and restore registers

; Parameters:
;		r1 = entry number
;		r2 = way to get
;		r8 = base I/O address of TLB control regs
; Returns:
;		r1 = TLBE low (PTE)
;		r2 = TLBE high

get_tlbe:
	build_entry_no %r3,%r1,%r0,$30
	store %r3,0x20[%r8]			; set entry number field
	nop											; wait a bit
	load %r1,0x00[%r8]			; get low order TLBE
	load %r2,0x08[%r8]			; get high order TLBE
	ret $0xFC								; do not restore r1,r2

; Parameters:
;		r1 = entry number
;		r2 = way to get
;		r3 = TLBE low (PTE)
;		r4 = TLBE high
;		r8 = base I/O address of TLB control regs
; Returns:

set_tlbe:
	store %r3,0x00[%r8]		; set low order TLBE
	store %r4,0x08[%r8]		; set high order TLBE
	build_entry_no %r5,%r1,%r0,$31
	store %r5,0x20[%r8]		; set entry number field
	ret $0xFF							; restore registers

;

; Go to low power wait mode.
; Wait for either an interrupt or the posting of a command to the command
; address. Capture the command in r7.
; If there was an interrupt, then the interrupt will return to the WAIT
; instruction, not the next line of code. So, WAIT forms an interrupt
; waiting loop all by itself. No need to loop back.
; On the other hand, if there is a command posted WAIT will transfer
; to the next instruction so the command can be processed.

idle_state:
	wait %r7,cmd_adr					; wait for a miss signal or command

process_cmd:
	loadi %r1,$7							; number of commands
	jge %r7,%r1,.bad_cmd			; return error if command out of range
	shl %r7,%r7,%r0,$3				; command to table index
	load %r7,CMD_table[%r7]		; get command function address
	call [%r7]								; go exeute the command
	store %r1,cmd_stat				; set status (error number)
	store $1,sig							; trigger the command done signal (interrupt?)
	jump idle_state						; go back for the next command
.bad_cmd:
	store $1,cmd_stat				; set 'bad' command status in command RAM area
	store $1,sig							; trigger the command done signal (interrupt?)
	jump idle_state						; go back for the next command

cmd_get_tlbe:
	load %r1,entryno					; r1 = entry number and way
	call get_tlbe
	store %r1,tlbeL						; set TLBE in arg area
	store %r2,tlbeH
cmd_ok:
	move %r1,%r0							; everything OK
	ret $0xFF

cmd_set_tlbe:
	load %r1,entryno
	load %r3,tlbeL						; get TLBE arg into r3,r4
	load %r4,tlbeH
	call set_tlbe
	jump cmd_ok

	.org 0x0200
frame_isr:
	ret $0xFF

; Allocate a page of memory.
; Sets the PAM bit for the page of memory allocated.
alloc_page:
	loadi %r4,$131072					; number of bits in PAM
	move %r2,%r4							; r4 = max bit
	loadi %r1,PAM_index
.0001:
	bmset %r2,PAM[%r1]				; set PAM bit and return previous setting
	jnez %r2,.0002						; was bit already set?
	load %r2,PAM_avail				; derement PAM available
	add %r2,%r2,%r0,$-1
	store %r2,PAM_avail
	store %r1,PAM_index				; update index for next time
	store %r1,cmd_resp				; save page number in arg area
	jump cmd_ok								; signal main CPU page selection is ready
.0002:
	add %r1,%r1,%r0,$1				; set up to check next bit bnumber
	jlt %r1,%r4,.0003
	xor %r1,%r1,%r1						; r1 = index zero
.0003:
	djnez %r4,.0001
	; Here the entire bitmap was searched and no free page was found.
	; Report out-of-memory condition
	store $-1,cmd_resp
	loadi %r1,$2							; 'out-of-memory' error
	ret $0xFF

; Free a page of memory
free_page:
	loadi %r4,$131072					; number of bits in PAM
	load %r1,cmd_arg1					; get page number to free
	jge %r1,%r4,cmd_ok				; ignore bad request
	bmclr %r1,PAM[%r1]				; clear the bit in the PAM
	load %r4,PAM_avail
	add %r4,%r4,%r1,$0				; increment pages available by free status
	store %r4,PAM_avail
	jump cmd_ok

; Get available page count
get_free_page_count:
	load %r1,PAM_avail
	store %r1,cmd_resp
	jmp cmd_ok

; Flush the TLB
; It can take a few cycles to flush the TLB, for example 512x4=2048 cycles.
; So that the main CPU is able to proceed, flushing is turned on and off
; periodically. Otherwise the TLB is disabled while flushing.
flush_all:
	loadi %r2,$0							; r2 = asid = 0
flush1:											; entry point for flush by asid
	flush %r0,%r2,$3					; trigger a flush operation
	loadi %r1,32							; wait a few cycles
.0001:
	djnez %r1,.0001
	flush %r3,%r2,$0					; turn flush off to allow translations
	jltz %r3,cmd_ok						; was the flush done?
	loadi %r1,32							; wait a few cycles
.0002:
	djnez %r1,.0002
	flush %r3,%r2,$1					; turn flush on to allow a few flushes
	jgtz %r3,.0001
	jump cmd_ok

; Flush TLB of a specific ASID
flush_asid:
	load %r2,cmd_arg1
	jump flush1

	.align 3
CMD_table:
	.2byte flush_all
	.2byte 0,0,0
	.2byte flush_asid
	.2byte 0,0,0
	.2byte cmd_get_tlbe
	.2byte 0,0,0
	.2byte cmd_set_tlbe
	.2byte 0,0,0
	.2byte alloc_page
	.2byte 0,0,0
	.2byte free_page
	.2byte 0,0,0
	.2byte get_free_page_count
	.2byte 0,0,0

	.data
	; Current index into the PAM
PAM_index:
	.8byte	0x0000

	; Location of TLB registers for each TLB ordered from TLBs
	; with the largest page sizes first.
	; Only the lower 48-bits are used.
	; The number of TLB entries-1 is stuffed in the upper 16 bits
	.rodata
tlb_regs_adr:
	.8byte 	0x01FFFFFFFFF40000	; smallest page size TLB
;	.8byte	0x007FFFFFFFF44000
;	.8byte	0x007FFFFFFFF48000
