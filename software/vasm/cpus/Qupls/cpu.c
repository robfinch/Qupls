#include "vasm.h"

// The following indicates to generate a block header and place instructions
// into 64 byte blocks. Currently must be used with the next constant.
//#define SUPPORT_IBH	1
// The following generates code to support postfix immediates.
//#define SUPPORT_PFX_IMM	1

// The following uses code supporting the shifted immediate instruction set.
// Where there are no immediate postfixes. It should not be defined when
// SUPPORT_PFX_IMM is defined.
#define SUPPORT_SI_IMM 1

// The following enables code to support memory page (64kB) relative branching.
// Generally not used.
//#define BRANCH_PGREL 1

// The following enables code to use instruction block slot numbers as the low
// order four bits of a branch target. It effectively gives branch displacements
// two more bits as the instruction slot number encodes into four bits instead of
// six bits. However, it does mean that code needs to be block (64 byte)
// relative.
//#define BRANCH_INO 1

// Ordinary PC relative branches
#define BRANCH_PCREL	1
#define NREG	32

#define TRACE(x)		/*printf(x)*/
#define TRACE2(x,y)	/*printf((x),(y))*/

extern char* qual[MAX_QUALIFIERS];
extern int qual_len[MAX_QUALIFIERS];

const char *cpu_copyright="vasm Qupls cpu backend (c) in 2023-2024 Robert Finch";

const char *cpuname="Qupls";
int bitsperbyte=8;
int bytespertaddr=8;
int abits=32;
static int bundleWidth = 128;
static taddr sdreg = 29;
static taddr sd2reg = 60;
static taddr sd3reg = 51;
static taddr pcreg = 53;
static __int64 regmask = 0x3fLL;

static int qupls_insn_count = 0;
static int qupls_byte_count = 0;
static int qupls_padding_bytes = 0;
static int qupls_header_bytes = 0;

static insn_sizes1[20000];
static insn_sizes2[20000];
static int sz1ndx = 0;
static int sz2ndx = 0;
static short int argregs[11] = {1,2,3,4,5,6,7,8,0,0,0};
static short int tmpregs[12] = {9,10,11,12,13,14,15,16,17,0,0,0};
static short int saved_regs[16] = {18,19,20,21,22,23,24,25,26,0,0,0,0,0,0,0};

static char *qualifiers[] =
{
	"b", "w", "t", "o", "h", "B", "W", "T", "O", "H",
	"s", "d", "q",
	"none", "io", "rd", "rda", "wt", "wta", "wb", "wba",
	"erc"
};

static int qualifiers_code[] =
{
	0, 1, 2, 3, 4, 0, 1, 2, 3, 4,
	2, 3, 4,
	0x80, 0x80, 0x81, 0x82, 0x80, 0x81, 0x82, 0x83,
	0x84
};

static char *regnames[32] = {
	"r0", "a0", "a1", "a2", "a3", "a4", "a5", "a6", 
	"a7", "t0", "t1", "t2", "t3", "t4", "t5", "t6",
	"t7", "t8", "s0", "s1", "s2", "s3", "s4", "s5",
	"s6", "s7", "s8",	"lr0", "lr1", "gp", "fp", "sp"
};

static int regop[32] = {
	OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, 
	OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, 
	OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, 
	OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG, OP_REG
};

mnemonic mnemonics[]={
	"abs",	{OP_REG,OP_REG,0,0,0}, {R2,CPU_ALL,0,0x01000002LL,5},

	"add", {OP_VREG,OP_VREG,OP_VREG,0,0}, {R2,CPU_ALL,0,R2FUNC(4LL)|OP4(8LL)|OPC(38LL),5,SZ_UNSIZED,0},	
	"add", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(4LL)|OP4(8LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"add", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(4LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"add", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(4LL),5,SZ_UNSIZED,0,0,OPC(2LL)|R2FUNC(4LL)},	
	"addh",{OP_REG,OP_IMM,0,0,0}, {RISH,CPU_ALL,0,0x6000LL|OPC(49LL),5,SZ_UNSIZED,0,0},
	"addm",{OP_REG,OP_IMM,0,0,0}, {RISM,CPU_ALL,0,0x2000LL|OPC(49LL),5,SZ_UNSIZED,0,0},
	"adds",{OP_REG,OP_IMM,OP_IMM,0,0}, {RIS,CPU_ALL,0,OPC(49LL),5,SZ_UNSIZED,0,0},

	"and", {OP_VREG,OP_VREG,OP_VREG,0,0}, {R2,CPU_ALL,0,R2FUNC(0)|OPC(38LL),5,SZ_UNSIZED,0},	
	"and", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(0)|OPC(2LL),5,SZ_UNSIZED,0},	
	"and", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(0)|OPC(2LL),5,SZ_UNSIZED,0},	
	"and", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(8LL),5,SZ_UNSIZED,0,0},	
	"andh",{OP_REG,OP_IMM,0,0,0}, {RISH,CPU_ALL,0,0x6000LL|OPC(50LL),5,SZ_UNSIZED,0,0},
	"andm",{OP_REG,OP_IMM,0,0,0}, {RISM,CPU_ALL,0,0x2000LL|OPC(50LL),5,SZ_UNSIZED,0,0},
	"ands",{OP_REG,OP_IMM,OP_IMM,0,0}, {RIS,CPU_ALL,0,OPC(50LL),5,SZ_UNSIZED,0,0},

	"asl", {OP_REG,OP_REG,OP_REG,0}, {SH,CPU_ALL,0,SHFUNC(0x00LL)|OPC(88LL),5,SZ_UNSIZED,0},	
	"asl", {OP_REG,OP_REG,OP_IMM,0}, {SI,CPU_ALL,0,SHFUNC(0x40LL)|OPC(88LL),5,SZ_UNSIZED,0},	
	"asr", {OP_REG,OP_REG,OP_REG,0}, {SH,CPU_ALL,0,SHFUNC(0x02LL)|OPC(88LL),5,SZ_UNSIZED,0},	
	"asr", {OP_REG,OP_REG,OP_IMM,0}, {SI,CPU_ALL,0,SHFUNC(0x42LL)|OPC(88LL),5,SZ_UNSIZED,0},	

	"atom", {OP_IMM,0,0,0,0}, {ATOM,CPU_ALL,0,FMT2(0)|OPC(122LL),5,SZ_UNSIZED,0},	

	"bbc",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,OPC(44LL),5,SZ_UNSIZED,0},
	"bbc",	{OP_REG,OP_IMM,OP_IMM,0,0}, {B,CPU_ALL,0,OPC(46LL),5,SZ_UNSIZED,0, FLG_UI6},
	"bbs",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,OPC(45LL),5,SZ_UNSIZED,0},
	"bbs",	{OP_REG,OP_IMM,OP_IMM,0,0}, {B,CPU_ALL,0,OPC(47LL),5,SZ_UNSIZED,0, FLG_UI6},
	"bcc",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,CM(1LL)|OPC(41LL),5,SZ_UNSIZED,0},

	"bcdadd", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3,CPU_ALL,0,0x0000000000F5LL,6},	
	"bcdmul", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3,CPU_ALL,0,0x0400000000F5LL,6},	
	"bcdsub", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3,CPU_ALL,0,0x0200000000F5LL,6},	

//	"bcs",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,CM(1LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"beq",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(4LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"beq",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(4LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"beqz",	{OP_REG,OP_IMM,0,0,0}, {B,CPU_ALL,0,BFN(4LL)|OPC(40LL),5,SZ_UNSIZED,0},

//	"beven",	{OP_REG,OP_IMM,0,0,0}, {B,CPU_ALL,0,COND(13LL)|OPC(28LL),5},

	"bge",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(4LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"bge",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(4LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"bgeu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(4LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"bgeu",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(4LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"bgt",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(5LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"bgt",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(5LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"bgtu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(5LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"bgtu",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(5LL)|OPC(40LL),5,SZ_UNSIZED,0},
//	"bhi",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,CM(1LL)|OPC(43LL),5,SZ_UNSIZED,0},
//	"bhs",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,CM(1LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"ble",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(3LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"ble",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(3LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"bleu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(3LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"bleu",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(3LL)|OPC(40LL),5,SZ_UNSIZED,0},
//	"blo",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,CM(1LL)|OPC(40LL),5,SZ_UNSIZED,0},
//	"bls",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,CM(1LL)|OPC(42LL),5,SZ_UNSIZED,0},
	"blt",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(2LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"blt",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(2LL)|OPC(41LL),5,SZ_UNSIZED,0},
	"bltu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(2LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"bltu",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(2LL)|OPC(40LL),5,SZ_UNSIZED,0},

	"bmap", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,FMT3(0)|R2FUNC(35)|IM2(0)|OPC(2LL),5,SZ_UNSIZED,0},	
	"bmm", 	{OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,FMT3(0)|R2FUNC(34)|IM2(0)|OPC(2LL),5,SZ_UNSIZED,0},	

	"bne",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(1LL)|OPC(40LL),5,SZ_UNSIZED,0},
	"bne",	{OP_REG,OP_IMM,OP_IMM,0,0}, {BI,CPU_ALL,0,BFN(1LL)|OPC(40LL),5,SZ_UNSIZED,0},

	"bnez",	{OP_REG,OP_IMM,0,0,0}, {B,CPU_ALL,0,BFN(1LL)|OPC(40LL),5,SZ_UNSIZED,0},
//	"bodd",	{OP_REG,OP_IMM,0,0,0}, {B,CPU_ALL,0,COND(5LL)|OPC(28LL),5},
//	"bodd",	{OP_REG,OP_IMM,0,0,0}, {B,CPU_ALL,0,COND(5LL)|OPC(28LL),5},

	"bra",	{OP_IMM,0,0,0,0}, {B2,CPU_ALL,0,OPC(32LL),5,SZ_UNSIZED,0},

	"brk",	{0,0,0,0,0}, {R1,CPU_ALL,0,0x00,5,SZ_UNSIZED,0},

	"bsr",	{OP_IMM,0,0,0,0}, {B2,CPU_ALL,0,RT(56LL)|OPC(32LL),5,SZ_UNSIZED,0},
	"bsr",	{OP_LK,OP_IMM,0,0,0}, {BL2,CPU_ALL,0,OPC(32LL),5,SZ_UNSIZED,0},

	"bytndx", 	{OP_REG,OP_REG,OP_REG,0,0}, {R3,CPU_ALL,0,0xAA0000000002LL,6},	
	"bytndx", 	{OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,0x00000055LL,4},

	"chk", 	{OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3,CPU_ALL,0,0x320000000002LL,6},	
	"chk", 	{OP_REG,OP_REG,OP_REG,OP_IMM,0}, {R3,CPU_ALL,0,0x000000000045LL,6},	

	"clmul", 	{OP_REG,OP_REG,OP_REG,0,0}, {R3,CPU_ALL,0,0x5C0000000002LL,6},	
	"clmulh", 	{OP_REG,OP_REG,OP_REG,0,0}, {R3,CPU_ALL,0,0x5E0000000002LL,6},	

	"clr", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(56LL)|OPC(13LL),5},	
	"clr", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,OP_IMM,0}, {BFR3II,CPU_ALL,0,FUNC3(0LL)|OPC(13LL),5},	

	"cmovnz", 	{OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3,CPU_ALL,0,0x5A0000000002LL,6},	

	"cmp", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(3LL)|IM2(0)|OPC(2LL),5,SZ_UNSIZED,0},	
	"cmp", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(3LL)|IM2(1)|OPC(2LL),5,SZ_UNSIZED,0},	
	"cmp", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(11LL),5,SZ_UNSIZED,0,0},	

	"cntlz", {OP_VREG,OP_VREG,0,0,0}, {R1,CPU_ALL,0,0x00000101,5},
	"cntlz", {OP_REG,OP_REG,0,0,0}, {R1,CPU_ALL,0,0x00000001,5},
	"cntpop", {OP_VREG,OP_VREG,0,0,0}, {R1,CPU_ALL,0,0x04000101,5},
	"cntpop", {OP_REG,OP_REG,0,0,0}, {R1,CPU_ALL,0,0x04000001,5},

	"com",	{OP_VREG,OP_VREG,0,0,0}, {R3II,CPU_ALL,0,0x1417F00001AALL,6},
	"com", {OP_REG,OP_REG,0,0,0}, {RI,CPU_ALL,0,0xfffff80000LL|OPC(10LL),5},

	"cpuid", {OP_REG,OP_REG,0,0,0}, {R1,CPU_ALL,0,0x41LL,4},
	
	"csrrc", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,FUNC3(3)|OPC(7),5,SZ_UNSIZED,0},
	"csrrd", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,FUNC3(0)|OPC(7),5,SZ_UNSIZED,0},
	"csrrs", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,FUNC3(2)|OPC(7),5,SZ_UNSIZED,0},
	"csrrw", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,FUNC3(1)|OPC(7),5,SZ_UNSIZED,0},
	"csrwr", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,FUNC3(1)|OPC(7),5,SZ_UNSIZED,0},

	"dbra",	{OP_IMM,0,0,0,0},{B,CPU_ALL,0,0x00001F000021LL,5,SZ_UNSIZED,0},

	"di",		{OP_NEXTREG,OP_NEXTREG,OP_REG,0,0}, {R3RR,CPU_ALL,0,0x2C0000000007LL,6},
	"dif",	{OP_REG,OP_REG,OP_REG,0,0}, {R3RR,CPU_ALL,0,0x280000000002LL,6},

	"div", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(17LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"div", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(13LL),5,SZ_UNSIZED,0},	

	"divu", {OP_VREG,OP_VREG,OP_VREG,OP_VMREG,0}, {R3RR,CPU_ALL,0,0x220000000102LL,6},	
	"divu", {OP_VREG,OP_VREG,OP_VREG,0,0}, {R3RR,CPU_ALL,0,0x220000000102LL,6},	
	"divu", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(20LL)|OPC(2LL),5},	
	"divu", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(21LL),5},

	"djmp",	{OP_IMM,0,0,0,0},{J2,CPU_ALL,0,0x000000000021LL,6},
	"djmp",	{OP_LK,OP_IMM,0,0,0},{JL2,CPU_ALL,0,0x000000000021LL,6},

	"enor", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(2LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"enor", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(2LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"enor", {OP_REG,OP_REG,OP_IMM,0,0}, {RIB,CPU_ALL,0,R2FUNC(2LL)|OPC(2LL),5,SZ_UNSIZED,0},	

	"enter", {OP_IMM,OP_IMM,0,0,0}, {ENTER,CPU_ALL,0,OPC(52LL),5,SZ_UNSIZED,0},	

	"eor", {OP_VREG,OP_VREG,OP_VREG,0,0}, {R2,CPU_ALL,0,R2FUNC(2LL)|OPC(38LL),5,SZ_UNSIZED,0},	
	"eor", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(2LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"eor", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(2LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"eor", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(10LL),5,SZ_UNSIZED,0,0},	
	"eorh",{OP_REG,OP_IMM,0,0,0}, {RISH,CPU_ALL,0,0x6000LL|OPC(59LL),5,SZ_UNSIZED,0,0},
	"eorm",{OP_REG,OP_IMM,0,0,0}, {RISM,CPU_ALL,0,0x2000LL|OPC(59LL),5,SZ_UNSIZED,0,0},
	"eors",{OP_REG,OP_IMM,OP_IMM,0,0}, {RIS,CPU_ALL,0,OPC(59LL),5,SZ_UNSIZED,0,0},

	"ext",	{OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(61)|OPC(13),5,SZ_INTALL,SZ_HEXI},
	"ext",	{OP_REG,OP_REG,OP_IMM,OP_IMM,0}, {BFR3II,CPU_ALL,0,FUNC3(5)|OPC(13),5,SZ_INTALL,SZ_HEXI},
	"exts",	{OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(61)|OPC(13),5,SZ_INTALL,SZ_HEXI},
	"exts",	{OP_REG,OP_REG,OP_IMM,OP_IMM,0}, {BFR3II,CPU_ALL,0,FUNC3(5)|OPC(13),5,SZ_INTALL,SZ_HEXI},
	"extu",	{OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(60)|OPC(13),5,SZ_INTALL,SZ_HEXI},
	"extu",	{OP_REG,OP_REG,OP_IMM,OP_IMM,0}, {BFR3II,CPU_ALL,0,FUNC3(4)|OPC(13),5,SZ_INTALL,SZ_HEXI},

	"fadd", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,0,0}, {R2,CPU_ALL,0,FUNC5(4LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fadd", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,0}, {RI,CPU_ALL,0,OPC(20LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fcmp", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,0,0}, {R2,CPU_ALL,0,FUNC5(5LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fcmp", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,0}, {RI,CPU_ALL,0,OPC(21LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fcmp", {OP_VREG|OP_REG,OP_IMM,OP_VREG|OP_REG,0}, {RIV,CPU_ALL,0,0x80000000LL|OPC(21LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	
	"fcvtdq", {OP_VREG|OP_REG,OP_VREG|OP_REG,0,0,0}, {R1,CPU_ALL,0,FLT1(11)|FUNC5(1)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	
	"fdiv", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,0,0}, {R2,CPU_ALL,0,FUNC5(7LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fdiv", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,0}, {RI,CPU_ALL,0,OPC(23LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fdiv", {OP_VREG|OP_REG,OP_IMM,OP_VREG|OP_REG,0}, {RIV,CPU_ALL,0,0x80000000LL|OPC(23LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fence",{OP_IMM,0,0,0,0},{BITS16,CPU_ALL,0,OPC(114LL),5,SZ_UNSIZED,0},
	"fmul", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,0,0}, {R2,CPU_ALL,0,FUNC5(6LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fmul", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,0}, {RI,CPU_ALL,0,OPC(22LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fneg", {OP_VREG|OP_REG,OP_VREG|OP_REG,0,0,0}, {R2,CPU_ALL,0,RB(34LL)|FUNC5(1LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fsub", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,0,0}, {R2,CPU_ALL,0,FUNC5(4LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	
	"fsub", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,0}, {RI,CPU_ALL,0,OPC(20LL),5,SZ_FLTALL,SZ_DOUBLE, FLG_NEGIMM,FLG_FP},	
	"ftoi", {OP_VREG|OP_REG,OP_VREG|OP_REG,0,0,0}, {R2,CPU_ALL,0,RB(2LL)|FUNC5(1LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	

	"ibeq",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(4LL)|0x800LL|OPC(40LL),5,SZ_UNSIZED,0},
	"ibge",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(4LL)|0x800LL|OPC(41LL),5,SZ_UNSIZED,0},
	"ibgeu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(4LL)|0x800LL|OPC(40LL),5,SZ_UNSIZED,0},
	"ibgt",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(5LL)|0x800LL|OPC(41LL),5,SZ_UNSIZED,0},
	"ibgtu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(5LL)|0x800LL|OPC(40LL),5,SZ_UNSIZED,0},
	"ibne",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(1LL)|0x800LL|OPC(40LL),5,SZ_UNSIZED,0},
	"ible",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(3LL)|0x800LL|OPC(41LL),5,SZ_UNSIZED,0},
	"ibleu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(3LL)|0x800LL|OPC(40LL),5,SZ_UNSIZED,0},
	"iblt",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(2LL)|0x800LL|OPC(41LL),5,SZ_UNSIZED,0},
	"ibltu",	{OP_REG,OP_REG,OP_IMM,0,0}, {B,CPU_ALL,0,BFN(2LL)|0x800LL|OPC(40LL),5,SZ_UNSIZED,0},

	"int",	{OP_IMM,OP_IMM,0,0,0}, {INT,CPU_ALL,0,0xA6LL,4},

	"itof", {OP_VREG|OP_REG,OP_VREG|OP_REG,0,0,0}, {R2,CPU_ALL,0,RB(3LL)|FUNC5(1LL)|OPC(12LL),5,SZ_FLTALL,SZ_DOUBLE,FLG_FP},	

	"jmp",	{OP_REGIND,0,0,0,0}, {J2,CPU_ALL,0,OPC(36LL),6, SZ_UNSIZED,0},
	"jmp",	{OP_REG,0,0,0,0}, {J2,CPU_ALL,0,OPC(36LL),6, SZ_UNSIZED,0},
	"jmp",	{OP_IMM,0,0,0,0}, {J2,CPU_ALL,0,OPC(36LL),6, SZ_UNSIZED,0},
	"jsr",	{OP_REGIND,0,0,0}, {J2,CPU_ALL,0,OPC(36LL),6, SZ_UNSIZED,0},
	"jsr",	{OP_LK,OP_IND_SCNDX,0,0,0}, {JSCNDX,CPU_ALL,0,R2FUNC(24LL)|0x80000000L|OPC(2LL),6, SZ_UNSIZED,0},
	"jsr",	{OP_LK,OP_REGIND,0,0,0}, {JL2,CPU_ALL,0,OPC(36LL),6, SZ_UNSIZED,0},
	"jsr",	{OP_LK,OP_IMM,0,0,0}, {JL2,CPU_ALL,0,OPC(36LL),6, SZ_UNSIZED,0},
	"jsr",	{OP_IMM,0,0,0,0}, {J2,CPU_ALL,0,OPC(36LL),6, SZ_UNSIZED,0},

	"lda",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(4LL),5, SZ_UNSIZED, 0},	
	"lda",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(4LL),5, SZ_UNSIZED, 0},	
	"lda",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(10LL)|S(3)|OPC(79LL),5, SZ_UNSIZED, 0},	

	"ldb",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(64LL),5, SZ_UNSIZED, SZ_BYTE},	
	"ldb",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(64LL),5, SZ_UNSIZED, SZ_BYTE},	
	"ldb",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(0)|OPC(79LL),5, SZ_UNSIZED, SZ_BYTE},	

	"ldbu",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(65LL),5, SZ_UNSIZED, SZ_BYTE},	
	"ldbu",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(65LL),5, SZ_UNSIZED, SZ_BYTE},	
	"ldbu",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,LSFUNC(1LL)|CPU_ALL,0,OPC(79LL),5, SZ_UNSIZED, SZ_BYTE},	
	"ldbz",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(65LL),5, SZ_UNSIZED, SZ_BYTE},	
	"ldbz",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(65LL),5, SZ_UNSIZED, SZ_BYTE},	
	"ldbz",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(1LL)|OPC(79LL),5, SZ_UNSIZED, SZ_BYTE},	

	"ldh",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(72LL),5, SZ_UNSIZED, SZ_HEXI},	
	"ldh",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(72LL),5, SZ_UNSIZED, SZ_HEXI},	
	"ldh",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(8LL)|OPC(79LL),5, SZ_UNSIZED, SZ_HEXI},	

	"ldi", {OP_VREG,OP_NEXT_VREG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(28LL),5,SZ_UNSIZED, 0},	
	"ldi", {OP_REG,OP_NEXTREG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(4LL),5,SZ_UNSIZED, 0},	

	"ldo",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(70LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldo",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(70LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldo",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(6LL)|OPC(79LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldou",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(71LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldou",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(71LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldou",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(7LL)|OPC(79LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldoz",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(71LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldoz",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(71LL),5, SZ_UNSIZED, SZ_OCTA},	
	"ldoz",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(7LL)|OPC(79LL),5, SZ_UNSIZED, SZ_OCTA},	

	"ldt",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(68LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldt",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(68LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldt",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(4LL)|OPC(79LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldtu",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(69LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldtu",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(69LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldtu",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(5LL)|OPC(79LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldtz",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(69LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldtz",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(69LL),5, SZ_UNSIZED, SZ_TETRA},	
	"ldtz",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(5LL)|OPC(79LL),5, SZ_UNSIZED, SZ_TETRA},	

	"ldw",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(66LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldw",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(66LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldw",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(2LL)|OPC(79LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldwu",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(67LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldwu",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(67LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldwu",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(3LL)|OPC(79LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldwz",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(67LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldwz",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(67LL),5, SZ_UNSIZED, SZ_WYDE},	
	"ldwz",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(3LL)|OPC(79LL),5, SZ_UNSIZED, SZ_WYDE},	

	"leave", {OP_IMM,OP_IMM,0,0,0}, {LEAVE,CPU_ALL,0,OPC(53LL),5,SZ_UNSIZED,0},	

	"lsr", {OP_REG,OP_REG,OP_REG,0}, {SH,CPU_ALL,0,SHFUNC(0x01LL)|OPC(88LL),5,SZ_UNSIZED,0},	
	"lsr", {OP_REG,OP_REG,OP_IMM,0}, {SI,CPU_ALL,0,SHFUNC(0x41LL)|OPC(88LL),5,SZ_UNSIZED,0},	

	"max",	{OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3RR,CPU_ALL,0,OPC(24LL),5},	
	"memdb",{0,0,0,0,0},{BITS16,CPU_ALL,0,0xff0000|OPC(114LL),5,SZ_UNSIZED,0},
	"memsb",{0,0,0,0,0},{BITS16,CPU_ALL,0,0xc00f00|OPC(114LL),5,SZ_UNSIZED,0},
	"min",	{OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3RR,CPU_ALL,0,0x80000000|OPC(24LL),5},	

	"mod", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(25LL)|OPC(2),5,SZ_INTALL,SZ_HEXI},
	"mod", {OP_REG,OP_REG,OP_IMM,0,0}, {RIL,CPU_ALL,0,R2FUNC(25LL)|OPC(2),5,SZ_INTALL,SZ_HEXI},
	"modu", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(28LL)|OPC(2),5,SZ_INTALL,SZ_HEXI},
	"modu", {OP_REG,OP_REG,OP_IMM,0,0}, {RIL,CPU_ALL,0,R2FUNC(28LL)|OPC(2),5,SZ_INTALL,SZ_HEXI},

	"mov", {OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,OPC(15LL),5, SZ_UNSIZED, 0},	
	"move", {OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,OPC(15LL),5, SZ_UNSIZED, 0},	
//	"mov",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,0x0817F00000AALL,6},
//	"move",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,0x0817F00000AALL,6},
	"movsxb",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,BFFUNC(2LL)|BFME(7LL)|BFMB(0LL)|OPC(39LL),5},
	"movsxt",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,BFFUNC(2LL)|BFME(31LL)|BFMB(0LL)|OPC(39LL),5},
	"movsxw",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,BFFUNC(2LL)|BFME(15LL)|BFMB(0LL)|OPC(39LL),5},
	"movzxb",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,BFFUNC(3LL)|BFME(7LL)|BFMB(0LL)|OPC(39LL),5},
	"movzxt",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,BFFUNC(3LL)|BFME(31LL)|BFMB(0LL)|OPC(39LL),5},
	"movzxw",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,BFFUNC(3LL)|BFME(15LL)|BFMB(0LL)|OPC(39LL),5},

	"mrts",	{0,0,0,0,0}, {RTS,CPU_ALL,0,0x01F2LL, 2},

	"mtlc",		{OP_NEXTREG,OP_REG,0,0,0}, {R2,CPU_ALL,0,0xA0000052LL,4},

	"mul", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(16LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"mul", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(6LL),5,SZ_UNSIZED,0,0},	

	"muladd", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3RR,CPU_ALL,0,0x0C0000000002LL,6},	

	"mulf", {OP_REG,OP_REG,OP_REG,0,0}, {R3RR,CPU_ALL,0,0x2A0000000002LL,6},	
	"mulf", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0x15LL,5},

	"mulh", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(24LL)|OPC(2LL),5},	

	"mulu", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(19LL)|OPC(2LL),5},	
	"mulu", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(14LL),5,SZ_UNSIZED,0,0},	

	"mux",	{OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3RR,CPU_ALL,0,OPC(25),5},	

	"nand", {OP_VREG,OP_VREG,OP_VREG|OP_REG|OP_IMM7,OP_VREG|OP_REG|OP_IMM7,0}, {R3,CPU_ALL,0,0x000000000102LL,6},	
	"nand", {OP_VREG,OP_VREG,OP_VREG|OP_REG|OP_IMM7,OP_VREG|OP_REG|OP_IMM7,OP_VMREG}, {R3,CPU_ALL,0,0x000000000102LL,6},	
	"nand", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(8LL)|OPC(2LL),5, SZ_INTALL, SZ_HEXI},	
	"nand", {OP_REG,OP_REG,OP_IMM,0}, {R3RI,CPU_ALL,0,R2FUNC(8LL)|OPC(2LL),5, SZ_INTALL, SZ_HEXI},	

	"neg", {OP_REG,OP_NEXTREG,OP_REG,0,0}, {R2,CPU_ALL,0,0x0000000DLL,4},	
//	"neg",	{OP_REG,OP_REG,0,0,0}, {R3,CPU_ALL,0,0x0A000001LL,4},

	"nop",	{0,0,0,0,0}, {BITS16,CPU_ALL,0,0xffffffffffLL,5, SZ_UNSIZED, 0},

	"nor", {OP_VREG,OP_VREG,OP_VREG|OP_REG|OP_IMM7,OP_VREG|OP_REG|OP_IMM7,0}, {R3,CPU_ALL,0,0x020000000102LL,6},	
	"nor", {OP_VREG,OP_VREG,OP_VREG|OP_REG|OP_IMM7,OP_VREG|OP_REG|OP_IMM7,OP_VMREG}, {R3,CPU_ALL,0,0x020000000102LL,6},	
	"nor", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {R2,CPU_ALL,0,R2FUNC(9LL)|OPC(2LL),5},	
	"not", {OP_REG,OP_REG,0,0,0}, {R1,CPU_ALL,0,R1FUNC(7LL)|OPC(1),5},

	"or", {OP_VREG,OP_VREG,OP_VREG,0,0}, {R2,CPU_ALL,0,R2FUNC(1LL)|OPC(38LL),5,SZ_UNSIZED,0},	
	"or", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(1LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"or", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(1LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"or", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(9LL),5,SZ_UNSIZED,0,0},	

	"orf", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VMREG,0}, {R2M,CPU_ALL,0,R2FUNC(9LL)|OPC(2LL),5, SZ_INTALL, SZ_HEXI},
	"orf", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,OP_VMREG,0}, {RIM,CPU_ALL,0,OPC(9LL),5, SZ_INTALL, SZ_HEXI},
	"orf", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(9LL)|OPC(2LL),5, SZ_INTALL, SZ_HEXI},	
	"orf", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,0}, {RI,CPU_ALL,0,OPC(9LL),5, SZ_INTALL, SZ_HEXI},	

	"orh",{OP_REG,OP_IMM,0,0,0}, {RISH,CPU_ALL,0,0x6000LL|OPC(51LL),5,SZ_UNSIZED,0,0},
	"orm",{OP_REG,OP_IMM,0,0,0}, {RISM,CPU_ALL,0,0x2000LL|OPC(51LL),5,SZ_UNSIZED,0,0},
	"ors",{OP_REG,OP_IMM,OP_IMM,0,0}, {RIS,CPU_ALL,0,OPC(51LL),5,SZ_UNSIZED,0,0},

	"padi", {0,0,0,0,0}, {PADI,CPU_ALL,0,0xFF,0},

	"peekq",	{OP_REG,OP_NEXTREG,OP_IMM,0,0},{R3RR,CPU_ALL,0,0x140000000007LL,6},	
	"peekq",	{OP_REG,OP_NEXTREG,OP_REG,0,0},{R3RR,CPU_ALL,0,0x140000000007LL,6},	

	"pcc",	{OP_REG,OP_PREDSTR,0,0,0}, {PRED,CPU_ALL,0,R2FUNC(32)|COND(11LL)|OPC(2LL),5, SZ_UNSIZED, 0},
	"pcs",	{OP_REG,OP_PREDSTR,0,0,0}, {PRED,CPU_ALL,0,R2FUNC(32)|COND(3LL)|OPC(2LL),5, SZ_UNSIZED, 0},
	"peq",	{OP_REG,OP_PREDSTR,0,0,0}, {PRED,CPU_ALL,0,R2FUNC(32)|COND(0LL)|OPC(2LL),5, SZ_UNSIZED, 0},
	"peven",	{OP_REG,OP_PREDSTR,0,0,0}, {PRED,CPU_ALL,0,R2FUNC(32)|COND(13LL)|OPC(2LL),5, SZ_UNSIZED, 0},

	"pfi",	{OP_REG,0,0,0,0},{R3RR,CPU_ALL,0,0x220000000007LL,6},	
	"pfx", 	{OP_IMM,0,0,0,0},{PFX,CPU_ALL,0,OPC(127LL),5,SZ_UNSIZED,0},

	"pop",	{OP_REG,OP_REG,OP_REG,OP_REG,0},{R4,CPU_ALL,0,0x200000037LL,5},	
	"pop",	{OP_REG,OP_REG,OP_REG,0,0},{R3,CPU_ALL,0,0x180000037LL,5},	
	"pop",	{OP_REG,OP_REG,0,0,0},{R3,CPU_ALL,0,0x100000037LL,5},	
	"pop",	{OP_REG,0,0,0,0},{R3,CPU_ALL,0,0x80000037LL,5},	

	"popq",	{OP_REG,OP_NEXTREG,OP_IMM,0,0},{R3RR,CPU_ALL,0,0x120000000007LL,6},	
	"popq",	{OP_REG,OP_NEXTREG,OP_REG,0,0},{R3RR,CPU_ALL,0,0x120000000007LL,6},	

	"pred",	{OP_NEXTREG,OP_REG,OP_PREDSTR,0,0}, {PRED,CPU_ALL,0,OPC(121LL),5, SZ_UNSIZED, 0},

	"ptghash", {OP_REG,OP_REG,0,0,0}, {R1,CPU_ALL,0,0x5E000001,4},

	"ptrdif",	{OP_REG,OP_REG,OP_REG,OP_IMM,0}, {R3RI,CPU_ALL,0,0x281000000002LL,6},
	"ptrdif",	{OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3RR,CPU_ALL,0,0x280000000002LL,6},

	"push",	{OP_REG,OP_REG,OP_REG,OP_REG,0},{R4,CPU_ALL,0,0x200000036LL,5},	
	"push",	{OP_REG,OP_REG,OP_REG,0,0},{R3,CPU_ALL,0,0x180000036LL,5},	
	"push",	{OP_REG,OP_REG,0,0,0},{R3,CPU_ALL,0,0x100000036LL,5},	
	"push",	{OP_REG,0,0,0,0},{R3,CPU_ALL,0,0x80000036LL,5},

	"pushq",	{OP_NEXTREG,OP_REG,OP_IMM,0,0},{R3RR,CPU_ALL,0,0x100000000007LL,6},	
	"pushq",	{OP_NEXTREG,OP_REG,OP_REG,0,0},{R3RR,CPU_ALL,0,0x100000000007LL,6},	

//	"rem", {OP_VREG,OP_VREG,OP_VREG,0,0}, {R3,CPU_ALL,0,0x200000000102LL,6},	
//	"rem", {OP_REG,OP_REG,OP_REG,0,0}, {R3RR,CPU_ALL,0,0x200000000002LL,6},	
//	"rem", {OP_REG,OP_REG,OP_IMM,0,0}, {RIL,CPU_ALL,0,0x42LL,6},
	"repbc", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(6LL)|OPC(0LL),5},
	"repbs", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(7LL)|OPC(0LL),5},
	"repdeq", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(0LL),5},
	"repdge", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(4LL)|OPC(3LL),5},
	"repdgt", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(5LL)|OPC(3LL),5},
	"repdle", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(3LL),5},
	"repdlt", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(2LL),5},
	"repdne", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(1LL),5},
	"repeq", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(0LL),5},
	"repge", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(4LL)|OPC(3LL),5},
	"repgt", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(5LL)|OPC(3LL),5},
	"repibc", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(6LL)|OPC(2LL),5},
	"repibs", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(7LL)|OPC(2LL),5},
	"repieq", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(0LL)|OPC(2LL),5},
	"repige", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(4LL)|OPC(2LL),5},
	"repigt", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(5LL)|OPC(2LL),5},
	"repile", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(3LL)|OPC(2LL),5},
	"repilt", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(2LL)|OPC(2LL),5},
	"repine", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|0x8000|CND3(1LL)|OPC(2LL),5},
	"reple", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(3LL),5},
	"replt", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(2LL),5},
	"repne", {OP_IMM,OP_IMM,0,0,0},{REP,CPU_ALL,0,R2FUNC(34LL)|CND3(2LL)|OPC(1LL),5},

	"resetq",	{OP_NEXTREG,OP_NEXTREG,OP_IMM,0,0},{R3RR,CPU_ALL,0,0x180000000007LL,6},	
	"resetq",	{OP_NEXTREG,OP_NEXTREG,OP_REG,0,0},{R3RR,CPU_ALL,0,0x180000000007LL,6},	

	"revbit",	{OP_REG,OP_REG,0,0,0}, {R1,CPU_ALL,0,0x50000001LL,5},

//	"ret", {OP_REG,0,0,0,0}, {RTDR,CPU_ALL,0,0x80000000LL|R2FUNC(4LL)|OPC(2LL),5,SZ_INTALL,SZ_HEXI},	
	"ret", {OP_NEXTREG,OP_REG,0,0,0}, {RTDR,CPU_ALL,0,RTYPE(0LL)|OPC(35LL),5,SZ_UNSIZED,0},	
	"ret", {0,0,0,0,0}, {RTDR,CPU_ALL,0,RA(56LL)|RTYPE(0LL)|OPC(35LL),5,SZ_UNSIZED,0},	

	"rex",	{OP_IMM,OP_REG,0,0,0},{REX,CPU_ALL,0,0x200000000007LL,5},	

	"rol", {OP_REG,OP_REG,OP_REG,0}, {SH,CPU_ALL,0,SHFUNC(0x03LL)|OPC(88LL),5,SZ_UNSIZED,0},	
	"rol", {OP_REG,OP_REG,OP_IMM,0}, {SI,CPU_ALL,0,SHFUNC(0x43LL)|OPC(88LL),5,SZ_UNSIZED,0},	
	"ror", {OP_REG,OP_REG,OP_REG,0}, {SH,CPU_ALL,0,SHFUNC(0x04LL)|OPC(88LL),5,SZ_UNSIZED,0},	
	"ror", {OP_REG,OP_REG,OP_IMM,0}, {SI,CPU_ALL,0,SHFUNC(0x44LL)|OPC(88LL),5,SZ_UNSIZED,0},	

	"rtd", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {RTDR,CPU_ALL,0,0x80000000LL|R2FUNC(4LL)|OPC(2LL),5,SZ_INTALL,SZ_HEXI},	
	"rtd", {OP_NEXTREG,OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM}, {RTDI,CPU_ALL,0,0x80000000LL|OPC(4LL),5,SZ_INTALL,SZ_HEXI},	
	"rtd", {OP_REG,OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM}, {RTDI,CPU_ALL,0,0x80000000LL|OPC(4LL),5,SZ_INTALL,SZ_HEXI},	
	"rtd", {OP_NEXTREG,OP_IMM,OP_IMM,0,0}, {RTDR,CPU_ALL,0,RTYPE(0LL)|RA(56LL)|OPC(35LL),5,SZ_INTALL,SZ_HEXI},	
	"rte",	{0,0,0,0,0}, {RTDR,CPU_ALL,0,RTYPE(1LL)|OPC(35LL), 5},
	"rte2",	{0,0,0,0,0}, {RTDR,CPU_ALL,0,RTYPE(2LL)|OPC(35LL), 5},
	"rti",	{0,0,0,0,0}, {RTDR,CPU_ALL,0,RTYPE(1LL)|OPC(35LL), 5},
	"rti2",	{0,0,0,0,0}, {RTDR,CPU_ALL,0,RTYPE(2LL)|OPC(35LL), 5},
	"rts", {OP_NEXTREG,OP_REG,0,0,0}, {RTDR,CPU_ALL,0,RTYPE(0LL)|OPC(35LL),5,SZ_INTALL,SZ_HEXI},	
	"rts", {0,0,0,0,0}, {RTDR,CPU_ALL,0,RTYPE(0LL)|RA(56LL)|OPC(35LL),5,SZ_UNSIZED,0},	

	"sbx", {OP_VREG|OP_REG,OP_VREG|OP_REG,OP_IMM,OP_IMM,0}, {RII,CPU_ALL,0,FUNC3(3LL)|OPC(13LL),5,SZ_INTALL,SZ_HEXI},	

	"sei",	{OP_REG,OP_NEXTREG,OP_REG,0,0},{R3RR,CPU_ALL,0,0x2E0000000007LL,6},	

	"seq", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(16LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"seq", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(16LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"seq", {OP_REG,OP_REG,OP_IMM,0,0}, {RIB,CPU_ALL,R2FUNC(16LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sle", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(19LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sle", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(19LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sle", {OP_REG,OP_REG,OP_IMM,0,0}, {RIB,CPU_ALL,0,R2FUNC(19LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sleu", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(21LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sleu", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(21LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sleu", {OP_REG,OP_REG,OP_IMM,0,0}, {RIB,CPU_ALL,0,R2FUNC(21LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"slt", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(18LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"slt", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(18LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"slt", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(3LL),5,SZ_UNSIZED,0},	
//	"seq", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3RR,CPU_ALL,0,0x4C0000000002LL,6},	
//	"seq", {OP_REG,OP_REG,OP_REG,OP_IMM,0}, {R3RI,CPU_ALL,0,0x4C0000000002LL,6},	

//	"slt", {OP_REG,OP_REG,OP_REG,0,0}, {R3,CPU_ALL,0,0x400000000002LL,6},	

	"sll",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_REG|OP_IMM7,OP_VMREG}, {R3,CPU_ALL,0,0x800000000002LL,6},	
	"sll",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_REG|OP_IMM7,0}, {R3,CPU_ALL,0,0x800000000002LL,6},	
	"sll",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_VMREG,0}, {R2,CPU_ALL,0,SHFUNC(0LL)|OPC(88LL),4},
//	"sll",	{OP_REG,OP_REG,OP_IMM,0,0}, {SHIFTI,CPU_ALL,0,0x800000000002LL,6},
	"sll",	{OP_REG,OP_REG,OP_IMM,0,0}, {RI6,CPU_ALL,0,SHFUNC(0LL)|OPC(88LL),5},
	"sll",	{OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,SHFUNC(0LL)|OPC(88LL),5},

//	"sne", {OP_REG,OP_REG,OP_REG,OP_IMM,0}, {R3RI,CPU_ALL,0,0x4E0000000002LL,6},	
//	"sne", {OP_REG,OP_REG,OP_REG,OP_REG,0}, {R3RR,CPU_ALL,0,0x4E0000000002LL,6},	
	"sne", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(17LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sne", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(17LL)|OPC(26LL),5,SZ_UNSIZED,0},	
	"sne", {OP_REG,OP_REG,OP_IMM,0,0}, {RIB,CPU_ALL,0,R2FUNC(17LL)|OPC(26LL),5,SZ_UNSIZED,0},	

	"sra",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_REG|OP_IMM7,OP_VMREG}, {R2,CPU_ALL,0,0x840000000002LL,4},	
	"sra",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_REG|OP_IMM7,0}, {R3,CPU_ALL,0,0x840000000002LL,4},	
	"sra",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_VMREG,0}, {R3,CPU_ALL,0,0x840000000002LL,4},	
//	"sra",	{OP_REG,OP_REG,OP_IMM,0,0}, {SHIFTI,CPU_ALL,0,0x840000000002LL,6},
	"sra",	{OP_REG,OP_REG,OP_IMM,0,0}, {RI6,CPU_ALL,0,SHFUNC(2LL)|OPC(88LL),4},
	"sra",	{OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,SHFUNC(2LL)|OPC(88LL),4},

	"srl",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_REG|OP_IMM7,OP_VMREG}, {R3,CPU_ALL,0,0x820000000002LL,6},	
	"srl",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_REG|OP_IMM7,0}, {R3,CPU_ALL,0,0x820000000002LL,6},	
	"srl",	{OP_REG,OP_REG,OP_REG|OP_IMM7,OP_VMREG,0}, {R3,CPU_ALL,0,0x820000000002LL,6},	
//	"srl",	{OP_REG,OP_REG,OP_IMM,0,0}, {SHIFTI,CPU_ALL,0,0x820000000002LL,6},
	"srl",	{OP_REG,OP_REG,OP_IMM,0,0}, {RI6,CPU_ALL,0,SHFUNC(1LL)|OPC(88LL),5},
	"srl",	{OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,SHFUNC(1LL)|OPC(88LL),5},

	"statq",	{OP_REG,OP_NEXTREG,OP_IMM,0,0},{R3RR,CPU_ALL,0,0x160000000007LL,6},	
	"statq",	{OP_REG,OP_NEXTREG,OP_REG,0,0},{R3RR,CPU_ALL,0,0x160000000007LL,6},	

	"stb",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(80LL),5, SZ_UNSIZED, SZ_BYTE},	
	"stb",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(80LL),5, SZ_UNSIZED, SZ_BYTE},	
	"stb",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(0)|OPC(87LL),5, SZ_UNSIZED, SZ_BYTE},	

	"sth",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(84LL),5, SZ_UNSIZED, SZ_HEXI},	
	"sth",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(84LL),5, SZ_UNSIZED, SZ_HEXI},	
	"sth",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(4LL)|OPC(87LL),5, SZ_UNSIZED, SZ_HEXI},	

	"sto",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(83LL),5, SZ_UNSIZED, SZ_OCTA},	
	"sto",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(83LL),5, SZ_UNSIZED, SZ_OCTA},	
	"sto",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(3LL)|OPC(87LL),5, SZ_UNSIZED, SZ_OCTA},	

	"stt",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(82LL),5, SZ_UNSIZED, SZ_TETRA},	
	"stt",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(82LL),5, SZ_UNSIZED, SZ_TETRA},	
	"stt",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(2LL)|OPC(87LL),5, SZ_UNSIZED, SZ_TETRA},	

	"stw",	{OP_REG,OP_IMM,0,0,0}, {DIRECT,CPU_ALL,0,OPC(81LL),5, SZ_UNSIZED, SZ_WYDE},	
	"stw",	{OP_REG,OP_REGIND,0,0}, {REGIND,CPU_ALL,0,OPC(81LL),5, SZ_UNSIZED, SZ_WYDE},	
	"stw",	{OP_REG,OP_SCNDX,0,0,0}, {SCNDX,CPU_ALL,0,LSFUNC(1LL)|OPC(87LL),5, SZ_UNSIZED, SZ_WYDE},	

	"sub", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(5LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"sub", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(5LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"sub", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(4LL),5,SZ_UNSIZED,0, FLG_NEGIMM},

	"subf", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(5LL),5,SZ_UNSIZED,0},	

/* 0000_1010_0001_0001_1111_0000_0000_0000_0000_0000_AALL */

	"sxb",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,0x8E000000LL|OPC(19LL),4},
	"sxc",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,0x9E000000LL|OPC(19LL),4},
	"sxt",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,0xBE000000LL|OPC(19LL),4},
	"sxw",	{OP_REG,OP_REG,0,0,0}, {MV,CPU_ALL,0,0x9E000000LL|OPC(19LL),4},

	"sync", {OP_IMM,0,0,0,0}, {SYNC,CPU_ALL,0,0xFF00|OPC(114LL),5},
	"sys",	{OP_IMM,0,0,0,0}, {BITS40,CPU_ALL,0,OPC(0LL),5},
	"syscall",	{0,0,0,0,0}, {BITS40,CPU_ALL,0,OPC(0LL),5},

	"vmask",	{OP_VMSTR,0,0,0,0}, {VMASK,CPU_ALL,0,R2FUNC(34)|OPC(2),5},

	"wfi", {0,0,0,0,0}, {BITS16,CPU_ALL,0,0xFALL,2},

	"wydendx", 	{OP_REG,OP_REG,OP_REG,0,0}, {R3,CPU_ALL,0,0x360000000002LL,6},	
	"wydendx", 	{OP_REG,OP_REG,OP_IMM,0,0}, {RIL,CPU_ALL,0,0x56LL,6},	

	/* Alternate mnemonic for enor */

	/* Alternate mnemonic for eor */
	"xor", {OP_REG,OP_REG,OP_REG,0,0}, {R2,CPU_ALL,0,R2FUNC(2LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"xor", {OP_REG,OP_IMM,OP_REG,0,0}, {RIA,CPU_ALL,0,R2FUNC(2LL)|OPC(2LL),5,SZ_UNSIZED,0},	
	"xor", {OP_REG,OP_REG,OP_IMM,0,0}, {RI,CPU_ALL,0,OPC(10LL),5,SZ_UNSIZED,0,0},	
	"xorh",{OP_REG,OP_IMM,0,0,0}, {RISH,CPU_ALL,0,0x6000LL|OPC(59LL),5,SZ_UNSIZED,0,0},
	"xorm",{OP_REG,OP_IMM,0,0,0}, {RISM,CPU_ALL,0,0x2000LL|OPC(59LL),5,SZ_UNSIZED,0,0},
	"xors",{OP_REG,OP_IMM,OP_IMM,0,0}, {RIS,CPU_ALL,0,OPC(59LL),5,SZ_UNSIZED,0,0},
};

const int mnemonic_cnt = sizeof(mnemonics)/sizeof(mnemonics[0]);

int qupls_data_operand(int n)
{
  if (n&OPSZ_FLOAT) return OPSZ_BITS(n)>64?OP_F128:OPSZ_BITS(n)>32?OP_F64:OP_F32;
  if (OPSZ_BITS(n)<=8) return OP_D8;
  if (OPSZ_BITS(n)<=16) return OP_D16;
  if (OPSZ_BITS(n)<=32) return OP_D32;
  if (OPSZ_BITS(n)<=64) return OP_D64;
  return OP_D128;
}

static int getextcode(char c)
{
  switch (tolower((unsigned char)c)) {
    case 'b':
      return EXT_BYTE;
    case 'w':
      return EXT_WYDE;
    case 't':
    	return EXT_TETRA;
    case 'o':
    	return EXT_OCTA;
    case 'h':
    	return EXT_HEXI;
    case 's':
      return EXT_SINGLE;
    case 'd':
      return EXT_DOUBLE;
    case 'q':
      return EXT_QUAD;
  }
  return -1;
}

/* convert lower-case extension character to a SIZE_xxx code */
static uint16_t lc_ext_to_size(char ext)
{
  switch (ext) {
    case 'b': return EXT_BYTE;
    case 'w': return EXT_WYDE;
    case 't': return EXT_TETRA;
    case 'o':	return EXT_OCTA;
    case 'h':	return EXT_HEXI;
    case 's': return EXT_SINGLE;
    case 'd': return EXT_DOUBLE;
    case 'q': return EXT_QUAD;
  }
  return -1;
}

/* parse instruction and save extension locations */
char *parse_instruction(char *s,int *inst_len,char **ext,int *ext_len,
                        int *ext_cnt)
{
  char *inst = s;

	TRACE("pi ");
  while (*s && *s!='.' && !isspace((unsigned char)*s))
    s++;
  *inst_len = s - inst;
//  printf("inslen: %d\n", *inst_len);
  while (*s =='.' && *ext_cnt < MAX_QUALIFIERS) {
    /* extension present */
    ext[*ext_cnt] = ++s;
    while (*s && *s!='.' && !isspace((unsigned char)*s))
      s++;
    ext_len[*ext_cnt] = s - ext[*ext_cnt];
    *ext_cnt += 1;
//    printf("extlen: %d, ext:%.50s\n", *ext_len, ext[(*ext_cnt)-1]);
  }
  return (s);
}

/* fill in pointers to default qualifiers, return number of qualifiers */
int set_default_qualifiers(char **q,int *q_len)
{
	TRACE("setdq ");
  q[0] = "o";
  q_len[0] = 1;
  return (1);
}

static int huge_chkrange2(thuge h,int bits)
{
  uint64_t v,mask;

  if (bits >= HUGEBITS)
    return 1;

  if (bits >= HUGEBITS/2) {
    mask = ~0LL << (bits - HUGEBITS/2);
    v = h.hi & mask;
    return (v & (1LL << (bits - HUGEBITS/2))) ? (v ^ mask) == 0 : v == 0;
  }    

  mask = ~0LL << bits;
  v = h.lo & mask;
  if (v & (1LL << bits))
    return h.hi == ~0 && (v ^ mask) == 0;
  return h.hi == 0 && v == 0;
}



/* check if a given value fits within a certain number of bits */
static int is_nbit(thuge val, int n)
{
	thuge low, high;
	return (huge_chkrange2(val, n));
  if (n > 95LL)
    return (1);
  low = hneg(hshl(huge_from_int(1LL), n-1LL));
  high = hshl(huge_from_int(1LL), n-1LL);
	return (hcmp(val,low) >= 0 && hcmp(val,high) < 0);
}
/*
static int is_nbit(thuge val, int64_t n)
{
	int r1, r2;
	thuge low, high;
//  if (n > 63)
//    return (1);
	low.lo = 1;
	low.hi = 0;
	low = hshl(low,(n-1LL));
	high = low;
	low = tsub(huge_zero(),low);
	low = -(1LL << (n - 1LL));
	high = (1LL << (n - 1LL));
	r1 = hcmp(val, low);
	r2 = hcmp(val, high);
	return (r1 >= 0 && r2 < 0);
}
*/
static int is_identchar(unsigned char ch)
{
	return (isalnum(ch) || ch == '_');
}

static int is_reg6(char *p, char **ep, int* typ)
{
	int nn;
	int sgn = 0;
	int n = 0;

	TRACE("is_reg6 ");
	if (ep)	
		*ep = p;
	if (p[0]=='-' || p[0]=='~') {
		sgn = 64;
		n = 1;
		while(p[n]==' ' || p[n]=='\t')
			n++;
	}
	
	for (nn = 0; nn < NREG; nn++) {
		if (p[n] == regnames[nn][0] && p[n+1]== regnames[nn][1]) {
			if (!ISIDCHAR((unsigned char)p[n+2])) {
				if (regnames[nn][2]=='\0') {
					if (ep)
						*ep = &p[2];
					*typ = regop[nn];
					return (nn);
				}
				return (-1);
			}
			if (regnames[nn][2]=='\0')
				return (-1);
			if (regnames[nn][2]==p[n+2]) {
				if (!ISIDCHAR((unsigned char)p[n+3])) {
					if (regnames[nn][3]=='\0') {
						*typ = regop[nn];
						if (ep)
							*ep = &p[n+3];
						return (nn);
					}
					return (-1);
				}
				if (regnames[nn][3]=='\0')
					return (-1);
				if (regnames[nn][3]==p[n+3]) {
					if (!ISIDCHAR((unsigned char)p[n+4])) {
						if (regnames[nn][4]=='\0') {
							if (ep)
								*ep = &p[n+4];
							*typ = regop[nn];
							return (nn);
						}
						return (-1);
					}
				}
			}
		}
	}
	return (-1);	
}

/* parse a general purpose register, r0 to r63 */
static int is_reg(char *p, char **ep)
{
	int rg = -1;
	int sgn = 0;
	int n = 0;

	TRACE("is_reg ");
	*ep = p;
	if (p[0]=='-' || p[0]=='~') {
		sgn = 64;
		n = 1;
		while(p[n]==' ' || p[n]=='\t')
			n++;
	}
	/* IP */
	if ((p[n]=='i' || p[n]=='I') && (p[n+1]=='p' || p[n+1]=='P') && !ISIDCHAR((unsigned char)p[n+2])) {
		*ep = &p[n+2];
		return (53);
	}
	/* PC */
	if ((p[n]=='p' || p[n]=='P') && (p[n+1]=='c' || p[n+1]=='C') && !ISIDCHAR((unsigned char)p[n+2])) {
		*ep = &p[n+2];
		return (53);
	}
	/* SP */
	if ((p[n]=='s' || p[n]=='S') && (p[n+1]=='p' || p[n+1]=='P') && !ISIDCHAR((unsigned char)p[n+2])) {
		*ep = &p[n+2];
		return (31);
	}
	/* FP */
	if ((p[n]=='f' || p[n]=='F') && (p[n+1]=='p' || p[n+1]=='P') && !ISIDCHAR((unsigned char)p[n+2])) {
		*ep = &p[n+2];
		return (30);
	}
	/* GP */
	if ((p[n]=='g' || p[n]=='G') && (p[n+1]=='p' || p[n+1]=='P') && !ISIDCHAR((unsigned char)p[n+2])) {
		*ep = &p[n+2];
		return (29);
	}
	/* GP0 */
	if ((p[n]=='g' || p[n]=='G') && (p[n+1]=='p' || p[n+1]=='P') && p[n+2]=='0' && !ISIDCHAR((unsigned char)p[n+3])) {
		*ep = &p[n+3];
		return (29);
	}
	/* Argument registers 0 to 7 */
	if (p[n] == 'a' || p[n]=='A') {
		if (isdigit((unsigned char)p[n+1]) && !ISIDCHAR((unsigned char)p[n+2])) {
			rg = p[n+1]-'0';
			rg = argregs[rg];	
			*ep = &p[n+2];
			return (rg+sgn);
		}
	}
	/* Temporary registers 0 to 8 */
	if (p[n] == 't' || p[n]=='T') {
		if (isdigit((unsigned char)p[n+1]) && !ISIDCHAR((unsigned char)p[n+2])) {
			rg = p[n+1]-'0';
			rg = tmpregs[rg];
			*ep = &p[n+2];
			return (rg);
		}
	}
	if (p[n] == 't' || p[n]=='T') {
		if (isdigit((unsigned char)p[n+1]) && isdigit((unsigned char)p[n+2]) && !ISIDCHAR((unsigned char)p[n+3])) {
			rg = (p[n+1]-'0') * 10 + p[n+2]-'0';	
			if (rg < 9) {
				rg = tmpregs[rg];
				*ep = &p[n+3];
				return (rg);
			}
		}
	}
	/* Register vars 0 to 8 */
	if (p[n] == 's' || p[n]=='S') {
		if (isdigit((unsigned char)p[n+1]) && !ISIDCHAR((unsigned char)p[n+2])) {
			rg = p[n+1]-'0';	
			rg = saved_regs[rg];
			*ep = &p[n+2];
			return (rg);
		}
	}
	if (p[n] == 's' || p[n]=='S') {
		if (isdigit((unsigned char)p[n+1]) && isdigit((unsigned char)p[n+2]) && !ISIDCHAR((unsigned char)p[n+3])) {
			rg = (p[n+1]-'0') * 10 + p[n+2]-'0';	
			if (rg < 9) {
				rg = saved_regs[rg];
				*ep = &p[n+3];
				return (rg);
			}
		}
	}
	/* LC */
	if ((p[n]=='l' || p[n]=='L') && (p[n+1]=='c' || p[n+1]=='C') && !ISIDCHAR((unsigned char)p[n+2])) {
		*ep = &p[n+2];
		return (55);
	}
	if (p[n] != 'r' && p[n] != 'R') {
		return (-1);
	}
	if (isdigit((unsigned char)p[n+1]) && isdigit((unsigned char)p[n+2]) && !ISIDCHAR((unsigned char)p[n+3])) {
		rg = (p[n+1]-'0')*10 + p[n+2]-'0';
		if (rg < 32) {
			*ep = &p[n+3];
			return (rg);
		}
		return (-1);
	}
	if (isdigit((unsigned char)p[n+1]) && !ISIDCHAR((unsigned char)p[n+2])) {
		rg = p[n+1]-'0';
		*ep = &p[n+2];
		return (rg);
	}
	return (-1);
}

/* parse a vector register, v0 to v63 */
static int is_vreg(char *p, char **ep)
{
	int rg = -1;
	int sgn = 0;
	int n = 0;
	
	*ep = p;
	if (p[0]=='-' || p[0]=='~') {
		sgn = 64;
		n = 1;
		while(p[n]==' ' || p[n]=='\t')
			n++;
	}

	if (p[n] != 'v' && p[n] != 'V') {
		return (-1);
	}
	if (isdigit((unsigned char)p[n+1]) && isdigit((unsigned char)p[n+2]) && !ISIDCHAR((unsigned char)p[n+3])) {
		rg = (p[n+1]-'0')*10 + p[n+2]-'0';
		if (rg < NREG) {
			*ep = &p[n+3];
			return (rg+sgn);
		}
		return (-1);
	}
	if (isdigit((unsigned char)p[n+1]) && !ISIDCHAR((unsigned char)p[n+2])) {
		rg = p[n+1]-'0';
		*ep = &p[n+2];
		return (rg+sgn);
	}
	return (-1);
}

/* parse a link register, lk0 to lk3 */
static int is_lkreg(char *p, char **ep)
{
	int rg = -1;

	*ep = p;
	if (*p != 'l' && *p != 'L') {
		return (-1);
	}
	if (p[1] != 'k' && p[1] != 'K' && p[1]!='r' && p[1]!='R') {
		return (-1);
	}
	if (isdigit((unsigned char)p[2]) && !ISIDCHAR((unsigned char)p[3])) {
		rg = p[2]-'0';
		if (rg < 2) {
			*ep = &p[3];
			return (rg+4);
		}
	}
	return (-1);
}

/* parse a code address register, ca0 to ca7 */
static int is_careg(char *p, char **ep)
{
	int rg = -1;

	*ep = p;
	/* IP */
	if ((p[0]=='I' || p[0]=='i') && (p[1]=='P' || p[1]=='p') && !ISIDCHAR((unsigned char)p[3])) {
		*ep = &p[3];
		return (7);
	}
	/* PC */
	if ((p[0]=='P' || p[0]=='p') && (p[1]=='C' || p[1]=='c') && !ISIDCHAR((unsigned char)p[3])) {
		*ep = &p[3];
		return (7);
	}
	if (*p != 'c' && *p != 'C') {
		return (-1);
	}
	if (p[1] != 'a' && p[1] != 'A') {
		return (-1);
	}
	if (isdigit((unsigned char)p[2]) && !ISIDCHAR((unsigned char)p[3])) {
		rg = p[2]-'0';
		if (rg < 8) {
			*ep = &p[3];
			return (rg);
		}
	}
	return (-1);
}

/* Parse a vector mask register, vm0 to vm7
	 The 'z' indicator follows the register number.
	 vm5z for instance indicates to zero out masked results, while
	 vm5 by itself indicates to not modify the masked result register.
*/
static int is_vmreg(char *p, char **ep)
{
	int rg = -1;
	int z = 0;

	*ep = p;
	if (*p != 'v' && *p != 'V') {
		return (-1);
	}
	if (p[1] != 'm' && p[1] != 'M') {
		return (-1);
	}
	if (isdigit((unsigned char)p[2])) {
		if (p[3]=='Z' || p[3]=='z') {
			p++;
			z = 1;
		}
		if (!ISIDCHAR((unsigned char)p[3])) {
			rg = p[2]-'0';
			if (rg < 8) {
				rg = (rg << 1) + z;
				*ep = &p[3];
				return (rg);
			}
		}
	}
	return (-1);
}

static int is_predstr(char *p, char **ep)
{
	int nn;
	int val = 0;

	if (p[0]!='"')
		return (-1);
	for (nn = 1; nn < 10; nn++) {
		switch(p[nn]) {
		case 0:
			if (ep)
				*ep = &p[nn];
			return (-1);
		case '"':
			if (ep)
				*ep = &p[nn+1];
			printf("predval=%x\n",val);
			return (val);
		case 'I':
		case 'i':
			break;
		case 'T':
		case 't':
			val |= (1 << ((nn-1)*2));
			break;
		case 'F':
		case 'f':
			val |= (2 << ((nn-1)*2));
			break;
		}
	}
	printf("predval=%x\n",val);
	return (val);	
}

static int is_vmstr(char *p, char **ep)
{
	int nn;
	int val = 0;

	if (p[0]!='"')
		return (-1);
	for (nn = 1; nn < 10; nn++) {
		switch(p[nn]) {
		case 0:
			if (ep)
				*ep = &p[nn];
			return (-1);
		case '"':
			if (ep)
				*ep = &p[nn+1];
			return (val);
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
			val |= (p[nn]-'0') << (nn-1)*3;
			break;
		}
	}
	return (val);	
}

static int is_branch(mnemonic* mnemo)
{
	switch(mnemo->ext.format) {
	case B:
	case BI:
	case BZ:
	case BL:
	case B2:
	case BL2:
	case J2:
	case JL2:
	case J3:
	case JL3:
		return (1);
	}
	return (0);	
}

static char *parse_reloc_attr(char *p,operand *op)
{
	TRACE("prs_rel_attr");
  p = skip(p);
  while (*p == '@') {
    unsigned char chk;

    p++;
    chk = op->attr;
    if (!strncmp(p,"got",3)) {
      op->attr = REL_GOT;
      p += 3;
    }
    else if (!strncmp(p,"plt",3)) {
      op->attr = REL_PLT;
      p += 3;
    }
    else if (!strncmp(p,"sdax",4)) {
      op->attr = REL_SD;
      p += 4;
    }
    else if (!strncmp(p,"sdarx",5)) {
      op->attr = REL_SD;
      p += 5;
    }
    else if (!strncmp(p,"sdarel",6)) {
      op->attr = REL_SD;
      p += 6;
    }
    else if (!strncmp(p,"sectoff",7)) {
      op->attr = REL_SECOFF;
      p += 7;
    }
    else if (!strncmp(p,"local",5)) {
      op->attr = REL_LOCALPC;
      p += 5;
    }
    else if (!strncmp(p,"globdat",7)) {
      op->attr = REL_GLOBDAT;
      p += 7;
    }
    if (chk!=REL_NONE && chk!=op->attr)
      cpu_error(7);  /* multiple relocation attributes */
  }

  return p;
}

static char *parse_idx(char* p,operand* op, int* match)
{
	int rg, rg2, nrg, nrg2;
	int dmm;
	char *pp = p;

	TRACE("pndx ");
	if (match)
		*match = 0;	
	if (((rg = is_reg(p, &p)) >= 0) || (rg2 = is_reg6(p, &p, &dmm))) {
		op->basereg = rg >= 0 ? rg : rg2;
		p = skip(p);
		if (*p=='+') {
			p = skip(p+1);
			if (((nrg = is_reg(p, &p)) >= 0) || (nrg2 = is_reg6(p,&p, &dmm))) {
				op->ndxreg = nrg >= 0 ? nrg : nrg2;
    		p = skip(p);
    		op->type = OP_SCNDX;
    		if (*p=='*') {
    			switch(p[1]) {
    			case '1':	op->scale = 1; p = skip(p+2); break;
    			case '2': op->scale = 2; p = skip(p+2); break;
    			case '4': op->scale = 4; p = skip(p+2); break;
    			case '8': op->scale = 8; p = skip(p+2); break;
    			default: op->scale = -1; p = skip(p+1); break;
    			}
    		}
    		else
    			op->scale = 1;
			}
			else if ((nrg = is_vreg(p, &p)) >= 0) {
				op->ndxreg = nrg;
    		p = skip(p);
    		op->type = OP_SCNDX;
			}
			else {
				cpu_error(0);
				return (0);
			}
		}
		else {
			op->scale = 0;
			op->ndxreg = 0;
			op->type = OP_REGIND;
		}
		if (match)
			*match = pp!=p;
	}
	return (p);
}

int parse_operand(char *p,int len,operand *op,int optype)
{
	int rg, nrg, rg2, nrg2;
	int rv = PO_NOMATCH;
	char ch;
	int dmm,mtch;

	TRACE("PO ");
	op->attr = REL_NONE;
	op->mask = 0xffffffffffffffffLL;

  if (!OP_DATAM(optype)) {
    p = parse_reloc_attr(p,op);

		if (optype==OP_NEXTREG) {
	    op->type = OP_REG;
	    op->basereg = 0;
	    op->value = number_expr((taddr)0);
			return (PO_NEXT);
		}
		if (optype==OP_NEXT_VREG) {
	    op->type = OP_VREG;
	    op->basereg = 0;
	    op->value = number_expr((taddr)0);
			return (PO_NEXT);
		}
		if (optype==OP_NEXT) {
	    op->value = number_expr((taddr)0);
			return (PO_NEXT);
		}

	  p=skip(p);
	  if ((rg = is_reg6(p, &p, &op->type)) >= 0) {
	    op->basereg=rg;
	    op->value = number_expr((taddr)rg);
	  }
	  else if ((rg = is_reg(p, &p)) >= 0) {
	    op->type=OP_REG;
	    op->basereg=rg;
	    op->value = number_expr((taddr)rg);
	  }
	  else if ((rg = is_vreg(p, &p)) >= 0) {
	    op->type=OP_VREG;
	    op->basereg=rg;
	    op->value = number_expr((taddr)rg);
	  }
	  else if ((rg = is_careg(p, &p)) >= 0) {
	    op->type=OP_CAREG;
	    op->basereg=rg;
	    op->value = number_expr((taddr)rg);
	  }
	  else if ((rg = is_vmreg(p, &p)) >= 0) {
	    op->type=OP_VMREG;
	    op->basereg=rg;
	    op->value = number_expr((taddr)rg);
	  }
	  else if ((rg = is_lkreg(p, &p)) >= 0) {
	    op->type=OP_LK;
	    op->basereg=rg;
	    op->value = number_expr((taddr)rg);
	  }
	  else if ((rg = is_predstr(p, &p)) >= 0) {
	  	op->type = OP_PREDSTR;
	  	op->value = number_expr((taddr)rg);
	  }
	  else if(p[0]=='#'){
	    op->type=OP_IMM;
	    p=skip(p+1);
	    op->value=parse_expr_huge(&p);
	  }
	  else if(p[0]=='<'){
	    op->type=OP_IMM;
	    p=skip(p+1);
	    op->value=parse_expr_huge(&p);
	    op->mask = 0xfffffLL;
	  }
	  else if(p[0]=='?'){
	    op->type=OP_IMM;
	    p=skip(p+1);
	    op->value=parse_expr_huge(&p);
	    op->mask = 0xffffff00000LL;
	  }
	  else if(p[0]=='>'){
	    op->type=OP_IMM;
	    p=skip(p+1);
	    op->value=parse_expr_huge(&p);
	    op->mask = 0xfffff00000000000LL;
	  }
	  else{
	    int parent=0;
	    expr *tree;
	    op->type=-1;
	    if (*p == '[') {
	    	tree = number_expr((taddr)0);
	    	op->type = OP_REGIND;
	    }
	    else {
	    	tree=parse_expr_huge(&p);
	    	while (is_identchar(*p)) p++;
	    	op->type = OP_REGIND_DISP;
	    }
	    if(!tree)
	      return (PO_NOMATCH);
	   	op->type = OP_IMM;
	    if(*p=='['){
	      parent=1;
	      p=skip(p+1);
	    }
	    p=skip(p);
	    if(parent){
	    	p = parse_idx(p, op, &mtch);
	    	if (!mtch) {
		    	tree=parse_expr_huge(&p);
				  p = parse_reloc_attr(p,op);
	    		if (*p=='[') {
			      p=skip(p+1);
	    			p = parse_idx(p, op, &mtch);
	    			if (mtch) {
	    				op->type = OP_IND_SCNDX;
	    			}
			      if(*p!=']'){
							cpu_error(5);
							return (0);
						}
			      p=skip(p+1);
	    		}
	    	}
	      if(*p!=']'){
					cpu_error(5);
					return (0);
	      }
	      else
					p=skip(p+1);
	    }
	    op->value=tree;
	  }
		TRACE("p");
  	if(optype & op->type) {
    	return (PO_MATCH);
  	}
	}
	else {
	  op->value = OP_FLOAT(optype) ? parse_expr_float(&p) : parse_expr_huge(&p);
		op->type = optype;
		return (PO_MATCH);
	}
  return (PO_NOMATCH);
}

operand *new_operand()
{
	TRACE("newo ");
  operand *nw=mymalloc(sizeof(*nw));
  nw->type=-1;
  return (nw);
}

static void fix_reloctype(dblock *db,int rtype)
{
  rlist *rl;

	TRACE("fixrel ");
  for (rl=db->relocs; rl!=NULL; rl=rl->next)
    rl->type = rtype;
}


static int get_reloc_type(operand *op)
{
  int rtype = REL_NONE;

	TRACE("grel ");
  if (OP_DATAM(op->type)) {  /* data relocs */
    return (REL_ABS);
  }

  else {  /* handle instruction relocs */
  	switch(op->format) {
  	
  	/* BEQ r1,r2,target */
  	case B:
  	case BI:
  		if (op->number==0) {
  			rtype = REL_ABS;
  			break;
  		}
  		if (op->number==1) {
  			rtype = REL_ABS;
  			break;
  		}
 			rtype = REL_PC;
      break;

		/* BEQZ r2,.target */
		/* BRA	LR1,target */
  	case BZ:
  	case BL2:
	    if (op->number==0)
	    	rtype = REL_NONE;
	    else
 				rtype = REL_PC;
      break;

		/* BRA target */		
  	case B2:
    	rtype = REL_PC;
      break;
  		
		/* JMP target */
    case J2:
    	rtype = op->attr;
      switch (op->attr) {
        case REL_NONE:
          rtype = REL_ABS;
          break;
        case REL_PLT:
        case REL_GLOBDAT:
        case REL_SECOFF:
          rtype = op->attr;
          break;
        default:
          cpu_error(11); /* reloc attribute not supported by operand */
          break;
      }
      break;

		/* JMP LK1,target */
    case JL2:
    	rtype = op->attr;
    	if (op->number > 0)
	      switch (op->attr) {
	        case REL_NONE:
	          rtype = REL_ABS;
	          break;
	        case REL_PLT:
	        case REL_GLOBDAT:
	        case REL_SECOFF:
	          rtype = op->attr;
	          break;
	        default:
	          cpu_error(11); /* reloc attribute not supported by operand */
	          break;
	      }
      break;

		/* JEQZ r1,target */
    case J3:
    	if (op->number > 0)
	      switch (op->attr) {
	        case REL_NONE:
	          rtype = REL_ABS;
	          break;
	        case REL_PLT:
	        case REL_GLOBDAT:
	        case REL_SECOFF:
	          rtype = op->attr;
	          break;
	        default:
	          cpu_error(11); /* reloc attribute not supported by operand */
	          break;
	      }
      break;

		/* JEQZ LK1,r1,target */
    case JL3:
    	if (op->number > 1)
	      switch (op->attr) {
	        case REL_NONE:
	          rtype = REL_ABS;
	          break;
	        case REL_PLT:
	        case REL_GLOBDAT:
	        case REL_SECOFF:
	          rtype = op->attr;
	          break;
	        default:
	          cpu_error(11); /* reloc attribute not supported by operand */
	          break;
	      }
      break;

    default:
      switch (op->attr) {
        case REL_NONE:
          rtype = REL_ABS;
          break;
        case REL_GOT:
        case REL_PLT:
        case REL_SD:
          rtype = op->attr;
          break;
        default:
          cpu_error(11); /* reloc attribute not supported by operand */
          break;
      }
  	}
  }
  return (rtype);
}

/* Compute branch target field value using one of three different
  methods.
*/
static thuge calc_branch_disp(thuge val, taddr pc, int opt)
{
	uint64_t ino;
	uint64_t pg_offs;
	thuge pcx2;
	thuge valx2;

#ifdef BRANCH_PGREL        	
	ino = (val.lo & 0x3fLL) >> 2LL;
	pg_offs = ((val.lo >> 6LL) & 0x3ffLL;
	val.lo &= 0xffffffffffff0000LL;
	val = hsub(val,huge_from_int(pc & 0xffffffffffff0000LL));
	val = hshr(val,2);
	val.lo &= 0xffffffffffffc000LL;
	val.lo |= ino;
	val.lo |= pg_offs << 4LL;
#endif
#ifdef BRANCH_INO
	ino = (val.lo & 0x3fLL) >> 2LL;
	val.lo &= 0xffffffffffffffc0LL;
	val = hsub(val,huge_from_int(pc & 0xffffffffffffffc0LL));
	val = hshr(val,2);
	val.lo &= 0xfffffffffffffff0LL;
	val.lo |= ino;
#endif
#ifdef BRANCH_PCREL
/*
	valx2 = hmul(val,huge_from_int(2LL));
	pcx2 = hmul(huge_from_int(pc),huge_from_int(2LL));
	val = hsub(valx2,pcx2);
	if (opt)
		val = hdiv(val,huge_from_int(9LL));
	else
		val = hdiv(val,huge_from_int(2LL));
*/
	val = hsub(val,huge_from_int(pc));
	if (opt)
		val = hdiv(val,huge_from_int(5LL));
#endif
	return (val);
}

/* create a reloc-entry when operand contains a non-constant expression */
static thuge make_reloc(int reloctype,operand *op,section *sec,
                        taddr pc,rlist **reloclist, int *constexpr)
{
  thuge val;
  thuge shl64;
	uint64_t ino;
	char pc_is_odd = pc & 1LL;

	TRACE("M ");
	*constexpr = 1;
	val.lo = val.hi = 0LL;
  if (!eval_expr(op->value,&val.lo,sec,pc)) {
	  if (val.lo & 0x8000000000000000LL)
	  	val.hi = 0xFFFFFFFFFFFFFFFFLL;
//  if (!eval_expr_huge(op->value,&val)) {
  	*constexpr = 0;
    /* non-constant expression requires a relocation entry */
    symbol *base;
    int btype,pos,size,disp;
    thuge addend;
    taddr mask;

		base = NULL;
    btype = find_base(op->value,&base,sec,pc);
    pos = disp = 0;

    if (btype > BASE_ILLEGAL) {
      if (btype == BASE_PCREL) {
        if (reloctype == REL_ABS)
          reloctype = REL_PC;
        else
          goto illreloc;
      }

      if ((reloctype == REL_PC) && !is_pc_reloc(base,sec)) {
        /* a relative branch - reloc is only needed for external reference */
				TRACE("m");
				switch(op->format) {
				case BI:
					if (op->number > 1) {
			 			val = calc_branch_disp(val, pc, 5);
						return (val);
					}
					break;
				case BZ:
				case B:
		 			val = calc_branch_disp(val, pc, 5);
					return (val);
				case B2:
				case BL2:
		 			val = calc_branch_disp(val, pc, 0);
					return (val);
				}
      }

			eval_expr(op->value,&val.lo,sec,pc);
		  if (val.lo & 0x8000000000000000LL)
		  	val.hi = 0xFFFFFFFFFFFFFFFFLL;

      /* determine reloc size, offset and mask */
      if (OP_DATAM(op->type)) {  /* data operand */
        switch (op->type) {
          case OP_D8:
            size = 8;
            break;
          case OP_D16:
            size = 16;
            break;
          case OP_D32:
          case OP_F32:
            size = 32;
            break;
          case OP_D64:
          case OP_F64:
            size = 64;
            break;
          case OP_D128:
          case OP_F128:
            size = 128;
            break;
          default:
            ierror(0);
            break;
        }
        reloctype = REL_ABS;
        addend = val;
        mask = -1;
      		add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                           pos,size,disp,mask);
      }
      else {  /* instruction operand */
      	if (op->format != B2 && op->format != BL2)
        	addend = (btype == BASE_PCREL) ? hadd(val, huge_from_int(disp)) : val;
        else
        	addend = val;
      	switch(op->format) {
      	case B:
      	case BI:	/* ToDo: fix for branch to external, REL_QUPLS_BRANCH */
		      add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                         8,32,5,0xffffffffLL);
      		if (!is_nbit(addend,32)) {
			      add_extnreloc_masked(reloclist,base,addend.lo>>32LL,reloctype,
                         8,32,10,0xffffffffLL);
      			
      		}
      		break;
      	case B2:
      	case BL2:
	      	add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                         12,28,0,0xfffffffLL);
          break;
      	/* Unconditional jump */
        case J2:
        case JL2:
		      add_extnreloc_masked(reloclist,base,val.lo,reloctype,
                           19,21,0,0x1fffffLL);
          break;
				/* Short conditional jump */
      	case J3:
      	case JL3:
		      add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                           9,5,0,0x3eLL);
		      add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                           19,13,0,0x7ffc0LL);
          break;
        case RISM:
		      add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                         17,23,0,0x7ffffe00000LL);
          break;
        case RISH:
		      add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
	                       17,23,0,0xfffffc0000000000LL);
        	break;
        case RI:
        case RIV:
        case RIM:
        case RIMV:
        case RTDI:
        	if (is_nbit(addend,21)) {
		      	add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                          19,21,0,0x1fffffLL);
        	}	/* ToDo: fix for 31 bits and above */
        	break;

        case DIRECT:
        	if (is_nbit(addend,21)) {
		      	add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                          19,21,0,0x1fffffLL);
        	}
        	else {	// abits > 64
	          goto illreloc;
        	}
        	break;

        case REGIND:
        	if (op->basereg==sdreg) {
        		reloctype = REL_SD;
	        	if (is_nbit(addend,21)) {
				      	add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                           19,21,0,0x1fffffLL);
	        	}
	        	else {	// abits > 64
		          goto illreloc;
	        	}
        	}
        	else {
	        	if (is_nbit(addend,21)) {
			      	add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                           19,21,0,0x1fffffLL);
	        	}
	        	else {	// abits > 64
		          goto illreloc;
	        	}
        	}
        	break;

				/* Displacement not supported by assembler yet. */
        case SCNDX:
        case JSCNDX:
        	goto illreloc;
	       	break;
        default:
        		/* relocation of address as data */
			      add_extnreloc_masked(reloclist,base,addend.lo,reloctype,
                          0,63,0,0x7fffffffffffffffLL);
					;
      	}
      }
    }
    else if (btype != BASE_NONE) {
illreloc:
      general_error(38);  /* illegal relocation */
    }
  }
  else {
  	val.lo = val.hi = 0;
	  eval_expr(op->value,&val.lo,sec,pc);
	  if (val.lo & 0x8000000000000000LL)
	  	val.hi = 0xFFFFFFFFFFFFFFFFLL;
//		eval_expr_huge(op->value,&val);
		switch(op->format) {
		case BI:
			if (op->number > 1) {
	 			val = calc_branch_disp(val, pc, 5);
				return (val);
			}
			break;
		case BZ:
		case B:
 			val = calc_branch_disp(val, pc, 5);
			return (val);
		case B2:
		case BL2:
 			val = calc_branch_disp(val, pc, 0);
			return (val);
		}
  }

	TRACE("m");
  return (val);
}


static void encode_reg(instruction_buf* insn, operand *op, mnemonic* mnemo, int i)
{
	TRACE("enr ");
	if (insn) {
		switch(mnemo->ext.format) {
		case PRED:
			insn->opcode = insn->opcode | RA(op->basereg);
			break;
		case RI:
		case RII:
		case RTDI:
		case RIM:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			else if (i==3)
				insn->opcode = insn->opcode | (RC(op->basereg & 3LL));
			break;
		case RISH: case RISM:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			break;
		case RIV:
		case RIS:
		case RIMV:			
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==2)
				insn->opcode = insn->opcode | (RA(op->basereg));
			break;
		case BFR3IR:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			if (i==3)			
				insn->opcode = insn->opcode | (RC(op->basereg));
			break;
		case SI:
		case R1:
		case BFR3II:
		case RI6:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			break;
		case MV:
		case CSR:
		case R2:
		case R3RI:
		case BFR3RI:
		case SHIFTI:
		case SH:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			else if (i==2)
				insn->opcode = insn->opcode | (RB(op->basereg));
			break;
		
		case RTDR:
			if (i==0)
				insn->opcode = insn->opcode| (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode| (RA(op->basereg));
			/*
			else if (i==2)
				*insn = *insn| (RB(op->basereg & regmask));
			else if (i==3)
				*insn = *insn| (RC(op->basereg & 3LL));
			*/
			break;
		
		case R4:
		case R3:
		case R3RR:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			else if (i==2)
				insn->opcode = insn->opcode | (RB(op->basereg));
			else if (i==3)
				insn->opcode = insn->opcode | (RC(op->basereg));
			break;
		case B:
		case BI:
			if (i==0)
				insn->opcode = insn->opcode | (RA(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RB(op->basereg));
			break;			
		case BZ:
			if (i==0)
				insn->opcode = insn->opcode | (RA(op->basereg));
			break;			
		case BL2:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			break;			
		case J3:
			if (i==0)
				insn->opcode = insn->opcode | (RA(op->basereg));
			break;
		case BL:
			if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			else if (i==2)
				insn->opcode = insn->opcode | (RB(op->basereg));
			else if (i==3)
				insn->opcode = insn->opcode | (RC(op->basereg));
			break;
		case JL3:
			if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			break;
		case REGIND:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			break;
		case SCNDX:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RA(op->basereg));
			else if (i==2)
				insn->opcode = insn->opcode | (RB(op->basereg));
			break;
		case JSCNDX:
			if (i==0)
				insn->opcode = insn->opcode | (RA(op->basereg));
			else if (i==1)
				insn->opcode = insn->opcode | (RB(op->basereg));
			break;
		case DIRECT:
			if (i==0)
				insn->opcode = insn->opcode | (RT(op->basereg));
			break;
		}				
	}
}

static void encode_vreg(uint64_t* insn, operand *op, mnemonic* mnemo, int i)
{
	TRACE("envr ");
	if (insn) {
		switch(mnemo->ext.format) {
		case BFR3IR:
			if (i==0)
				*insn = *insn| (RT(op->basereg));
			else if (i==1)
				*insn = *insn| (RA(op->basereg & regmask));
			if (i==3)			
				*insn = *insn| (RC(op->basereg & regmask));
			break;

		case R1:
		case BFR3II:
		case RI:
		case RIM:
		case RTDI:
		case RII:
		case RI6:
			if (i==0)
				*insn = *insn| (RT(op->basereg));
			else if (i==1)
				*insn = *insn| (RA(op->basereg));
			else if (i==2)
				*insn = *insn| (RK(op->basereg));
			break;

		case RIV:
		case RIS: case RISH: case RISM:
		case RIMV:
			if (i==0)
				*insn = *insn| (RT(op->basereg));
			else if (i==2)
				*insn = *insn| (RA(op->basereg));
			else if (i==3)
				*insn = *insn| (RK(op->basereg));
			break;

		/*
		case RTDR:
		*/
		case R2:
		case R2M:
			if (i==0)
				*insn = *insn| (RT(op->basereg));
			else if (i==1)
				*insn = *insn| (RA(op->basereg));
			else if (i==2)
				*insn = *insn| (RB(op->basereg));
			else if (i==3)
				*insn = *insn| (RK(op->basereg));
			break;

		case MV:
		case CSR:
		case R3RI:
		case BFR3RI:
		case SHIFTI:
			if (i==0)
				*insn = *insn| (RT(op->basereg));
			else if (i==1)
				*insn = *insn| (RA(op->basereg));
			else if (i==2)
				*insn = *insn| (RB(op->basereg));
			break;

		case R4:
		case R3:
		case R3RR:
			if (i==0)
				*insn = *insn| (RT(op->basereg));
			else if (i==1)
				*insn = *insn| (RA(op->basereg));
			else if (i==2)
				*insn = *insn| (RB(op->basereg));
			else if (i==3)
				*insn = *insn| (RC(op->basereg));
			break;

		case B:
		case BI:
		case BZ:
		case BL2:
			break;
		case J3:
			if (i==0)
				*insn = *insn| (RA(op->basereg));
			break;
		case BL:
			if (i==1)
				*insn = *insn| (RA(op->basereg));
			else if (i==2)
				*insn = *insn| (RB(op->basereg));
			else if (i==3)
				*insn = *insn| (RCB(op->basereg));
			break;
		case JL3:
			if (i==1)
				*insn = *insn| (RA(op->basereg));
			break;

		case REGIND:
			if (i==0)
				*insn = *insn| (RA(op->basereg));
			else if (i==1)
				*insn = *insn| (RB(op->basereg));
			else if (i==2)
				*insn = *insn| (RK(op->basereg));
			break;
		case SCNDX:
			if (i==0)
				*insn = *insn| (RA(op->basereg));
			else if (i==1)
				*insn = *insn| (RB(op->basereg));
			else if (i==2)
				*insn = *insn| (RC(op->basereg));
			else if (i==3)
				*insn = *insn| (RK(op->basereg));
			break;
		case JSCNDX:
			if (i==0)
				*insn = *insn| (RA(op->basereg));
			else if (i==1)
				*insn = *insn| (RB(op->basereg));
			break;
		case DIRECT:
			if (i==0)
				*insn = *insn| (RA(op->basereg));
			else if (i==1)
				*insn = *insn| (RK(op->basereg));
			break;
		}				
	}
}

static void encode_reg6(instruction_buf* insn, operand *op, mnemonic* mnemo, int i)
{
	TRACE("enr6 ");
	if (insn) {
		switch(mnemo->ext.format) {
		case RI64:
		case RI48:
			if (i==0)
				insn->opcode = insn->opcode | RT(op->basereg);
			else if (i==1)
				insn->opcode = insn->opcode | RA(op->basereg);
		case R3R:
			if (i==0)
				insn->opcode = insn->opcode | RT(op->basereg);
			else if (i==1)
				insn->opcode = insn->opcode | RA(op->basereg);
			else if (i==2)
				insn->opcode = insn->opcode | RB(op->basereg);
			else if (i==3)
				insn->opcode = insn->opcode | RC(op->basereg);
		}				
	}
}

static size_t encode_immed_RI(instruction_buf* insn, thuge hval, int i, taddr pc, section* sec, instruction *ip)
{
	size_t isize = (insn->opcode & 0x7f)==7LL ? 5 : 5;
	int minbits = (insn->opcode & 0x7f)==7LL ? 15 : 21;
	int64_t sc;

	if (((insn->opcode & 0x7fLL)==OPC_ADDS)
		|| ((insn->opcode & 0x7fLL)==OPC_ANDS)
		|| ((insn->opcode & 0x7fLL)==OPC_ORS)
		|| ((insn->opcode & 0x7fLL)==OPC_EORS)
	)
	{
		minbits = 128;
		eval_expr(ip->op[2]->value,&sc,sec,pc);
		switch(sc) {
		case 1:	
			hval = hshr(hval,20);
			if (((insn->opcode & 0x7fLL)==OPC_ADDS)
				||((insn->opcode & 0x7fLL)==OPC_ORS)
				||((insn->opcode & 0x7fLL)==OPC_EORS)
			)
				hval.lo &= -2LL;
			else if ((insn->opcode & 0x7fLL)==OPC_ANDS)
				hval.lo |= 1LL;
			break;
		case 2:	hval = hshr(hval,40); break;
		}
	}

	if (hval.lo & 0x8000000000000000LL)
		hval.hi = 0xffffffffffffffffLL;

	if (insn) {
		insn->imm0 = 0LL;
		insn->imm1 = 0LL;
		insn->imm2 = 0LL;
		insn->imm3 = 0LL;
	}
#ifdef UNDEF
	if (i==1) {
		if (insn) {
			insn->pfxb.size = 0;
			//insn->opcode |= 0x400000LL;	// set swap bit
			insn->opcode = insn->opcode | ((hval.lo & 0x1fffffLL) << 19LL);
			if (!is_nbit(hval,minbits)){//||(hval.lo&0x1FE00LL)==0x10000LL) {
				insn->imm0 = OPC(9LL)|((hval.lo & 0xffffLL) << 23LL)|RA(0)|RT(51LL);	// ORI r51,r0,#imm16
				insn->imm1 = OPC(9LL)|(((hval.lo >> 16LL) & 0xffffLL)<<23LL)|RA(51LL)|RT(51LL)|SC(1LL);	// ORI r51,r51,#imm16<<16
				insn->pfxb.size = 5;
				insn->pfxb.val = hval;
				if (!is_nbit(hval,32)) {
					insn->imm2 = OPC(9LL)|((hval.hi & 0xffffLL)<<23LL)|RA(51LL)|RT(51LL)|SC(2LL);	// ORI r51,r51,#imm16<<32
					insn->imm3 = OPC(9LL)|(((hval.hi >> 16LL) & 0xffffLL)<<23LL)|RA(51LL)|RT(51LL)|SC(3LL);	// ORI r51,r51,#imm16<<48
					insn->pfxb.size = 10;
					if (!is_nbit(hval,64)) {
						insn->pfxb.size = 20;
					}
				}
			}
		}
	}
#endif
	if (i==1) {
		if (insn) {
			insn->pfxb.size = 0;
			//insn->opcode |= 0x400000LL;	// set swap bit
			insn->opcode = insn->opcode | ((hval.lo & 0x1fffffLL) << 19LL);
			if (!is_nbit(hval,minbits)){//||(hval.lo&0x1FE00LL)==0x10000LL) {
				insn->imm0 = OPC(9LL)|((hval.lo & 0x1fffffLL) << 19LL)|RA(0)|RT(51LL);	// ORI r51,r0,#imm21
				insn->imm1 = OPC(51LL)|(((hval.lo >> 21LL) & 0x7ffffffLL)<<13LL)|RT(51LL);	// ORIM r51,#imm27<<21
				if (!is_nbit(hval,48))
					insn->imm2 = OPC(59LL)|(((hval.lo >> 48LL) & 0x7ffffffLL)<<13LL)|RA(51LL);	// ORI r51,#imm27<<48
/*
				insn->imm0 = OPC(9LL)|((hval.lo & 0xffffLL) << 23LL)|RA(0)|RT(51LL);	// ORI r51,r0,#imm16
				insn->imm1 = OPC(9LL)|(((hval.lo >> 16LL) & 0xffffLL)<<23LL)|RA(51LL)|RT(51LL)|SC(1LL);	// ORI r51,r51,#imm16<<16
*/
				insn->pfxb.size = 5;
				insn->pfxb.val = hval;
				if (!is_nbit(hval,32)) {
					insn->pfxb.size = 10;
					if (!is_nbit(hval,64)) {
						insn->pfxb.size = 20;
					}
				}
			}
		}
	}
	if (i==2) {
		insn->pfxb.size = 0;
		if (insn) {
			if ((insn->opcode & 0x7f)==7LL)	// CSR
				insn->opcode = insn->opcode | ((hval.lo & 0x3fffLL) << 19LL);
			else
				insn->opcode = insn->opcode | ((hval.lo & 0x1fffffLL) << 19LL);
//				insn->opcode = insn->opcode | ((hval.lo & 0x1fffffLL) << 19LL);
		}
		if (!is_nbit(hval,minbits)) {
			if (insn) {
				insn->pfxb.size = 5;
				insn->pfxb.val = hval;
				insn->imm0 = OPC(9LL)|((hval.lo & 0xffffLL) << 23LL)|RA(0)|RT(51LL);	// ORI r51,r0,#imm16
				insn->imm1 = OPC(9LL)|(((hval.lo >> 16LL) & 0xffffLL)<<23LL)|RA(51LL)|RT(51LL)|SC(1LL);	// ORI r51,r51,#imm16<<16
				if (!is_nbit(hval,32)) {
					insn->pfxb.size = 10;
					insn->imm2 = OPC(9LL)|((hval.hi & 0xffffLL)<<23LL)|RA(51LL)|RT(51LL)|SC(2LL);	// ORI r51,r51,#imm16<<32
					insn->imm3 = OPC(9LL)|(((hval.hi >> 16LL) & 0xffffLL)<<23LL)|RA(51LL)|RT(51LL)|SC(3LL);	// ORI r51,r51,#imm16<<48
					if (!is_nbit(hval,64)) {
						insn->pfxb.size = 20;
					}
				}
			}
		}
	}
	return (isize);
}

static size_t encode_direct(instruction_buf* insn, thuge val, uint64_t mask,
	int i, taddr pc, section* sec, instruction* ip
	)
{
	size_t isize = 5;

	TRACE("endir ");
	return (encode_immed_RI(insn, val, i, pc, sec, ip));
	val.lo &= mask;

	// We can always encode if fewer than 22 address bits are needed.
	if (abits < 22) {
		if (insn)
			insn->opcode = insn->opcode | ((val.lo & 0x1fffffLL) << 19LL);
		return (isize);
	}
	// Also if the address will fit into a 21 bit value.
	if (is_nbit(val,22)) {
		if (insn)
			insn->opcode = insn->opcode | ((val.lo & 0x1fffffLL) << 19LL);
		return (isize);
	}
//	return (encode_immed_RI(insn,val,2));
	insn->pfxb.size = 0;
	insn->pfxb.val = val;
	insn->pfxb.size = 5;
	if (abits > 32) {
		insn->pfxb.size = 10;
	}
	if (abits > 64) {
		insn->pfxb.size = 20;
	}
	if (insn) {
		insn->opcode = insn->opcode | ((val.lo & 0x1fffffLL) << 19LL);
	}
	return (isize);
}

static size_t encode_immed_LDI(instruction_buf* insn, thuge hval, int i)
{
	size_t isize = 5;
	int minbits = 19LL;

	if (insn) {
		insn->opcode = insn->opcode | ((hval.lo & 0x7ffffLL) << 13LL);
		insn->size = 5;
	}
	if (i==1) {
		if (!is_nbit(hval,minbits)) {
			insn->pfxb.val = hval;
			insn->pfxb.size = 5;
			if (!is_nbit(hval,32)) {
				insn->pfxb.size = 10;
			}
			if (!is_nbit(hval,64)) {
				insn->pfxb.size = 20;
			}
		}
	}
	return (isize);
}

static void encode_ipfx(postfix_buf* postfix, thuge hval, int i)
{
	if (!postfix)
		return;
	if (i < 0 || i > 2) {
		printf("Illegal postfix index.\n");		
		exit(0);
	}
	postfix->val.lo = hval.lo;
	postfix->val.hi = hval.hi;
	if (is_nbit(hval,32LL)) {
		postfix->size = 5;
		switch(i) {
		case 0:	postfix->opcode = 56LL; break;
		case 1: postfix->opcode = 60LL; break;
		case 2: postfix->opcode = 48LL; break;
		}
		return;
	}
	if (is_nbit(hval,64LL)) {
		postfix->size = 10;
		switch(i) {
		case 0:	postfix->opcode = 56LL; break;
		case 1: postfix->opcode = 60LL; break;
		case 2: postfix->opcode = 48LL; break;
		}
		return;
	}
	postfix->size = 20;
	switch(i) {
	case 0:	postfix->opcode = 56LL; break;
	case 1: postfix->opcode = 60LL; break;
	case 2: postfix->opcode = 48LL; break;
	}
	return;
}

static size_t encode_immed (
	instruction_buf* insn, mnemonic* mnemo,
	operand *op, thuge hval, int constexpr, int i, char vector,
	taddr pc, section* sec, instruction* ip)
{
	size_t isize = 5;
	thuge val;

	TRACE("enimm ");
	/*
	if (mnemo->ext.format==PFX) {
		encode_ipfx(insn->postfix, hval, i);
		*pfxsize = 4;
		if (insn) *insn = *insn |	((hval.lo  & 0x7fffffLL) << 8LL);
		return (isize);
	}
	*/
	hval.lo &= op->mask;

//	if (hval.hi & 0x80000000LL)
//		hval.hi |= 0xFFFFFFFF00000000LL;

	if (mnemo->ext.flags & FLG_NEGIMM) {
		if (mnemo->ext.flags & FLG_FP)
			hval.hi ^= 0x8000000000000000LL;
		else
			hval = hneg(hval);	/* ToDo: check here for value overflow */
	}

	val = hval;
	if (constexpr) {
		if (mnemo->ext.format==RI) {
			isize = encode_immed_RI(insn, val, i, pc, sec, ip);
		}
		else if (mnemo->ext.format==LDI) {
			isize = encode_immed_LDI(insn, val, i);
		}
		else if (mnemo->ext.format==SI) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 19LL);
		}
		else if (mnemo->ext.format==ATOM) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0xffffffLL) << 7LL);
		}
		else if (mnemo->ext.format==DIRECT) {
			isize = encode_direct(insn, hval, op->mask, i, pc, sec, ip);
		}
		else if (mnemo->ext.format == CSR) {
			isize = 5;
			if (insn) {
				insn->opcode = insn->opcode | ((val.lo & 0xffLL) << 24LL) | (((val.lo) >> 8LL) << 33LL);
			}
		}
		else if (mnemo->ext.format == RTDR) {
			if (insn) {
				if (i==1)
					insn->opcode = insn->opcode | (((val.lo >> 3LL) & 0x3ffffLL) << 22LL);
				else if (i==2)
					insn->opcode = insn->opcode | ((val.lo & 0xfLL) << 7LL);
			}
		}
		else if (mnemo->ext.format == RTS) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & regmask) << 11LL);
		}
		else if (mnemo->ext.format==R2) {
			if (insn) {
				switch(i) {
				case 1:	encode_ipfx(&insn->pfxa,val,i-1); break;
				case 2:	encode_ipfx(&insn->pfxb,val,i-1); break;
				case 3:	encode_ipfx(&insn->pfxc,val,i-1); break;
				}
				if (mnemo->ext.opcode==0x5D)	// SLLH
					insn->opcode = insn->opcode | RB((val.lo >> 4LL));
				else
					insn->opcode = insn->opcode | RB(val.lo);
			}
		}
		else if (mnemo->ext.format==R3) {
			if (i==2) {
				if (insn)
					insn->opcode = insn->opcode | RB(val.lo);
			}
			else if (i==3)
				if (insn)
					insn->opcode = insn->opcode | RC(val.lo);
		}
		else if (mnemo->ext.format==BFR3RI || mnemo->ext.format==BFR3IR || mnemo->ext.format==BFR3II) {
			if (i==2) {
				if (insn)
					insn->opcode = insn->opcode | BFOFFS(val.lo);
			}
			else if (i==3)
				if (insn)
					insn->opcode = insn->opcode | BFWID(val.lo);
		}
		else if (mnemo->ext.format==SHIFTI) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 29LL);
		}
		else if (mnemo->ext.format==RI6) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0x3fLL) << 19LL);
		}
		else if (mnemo->ext.format==RII) {
			if (i==2) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 23LL);
			}
			else if (i==3) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 30LL);
			}
		}
		else if (mnemo->ext.format==CSRI) {
			if (i==1) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 16LL);
			}
			else if (i==2) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0xffLL) << 23LL) | (((val.lo >> 8LL) & 0x3fLL) << 32LL);
			}
		}

		else if (mnemo->ext.format==J2) {
			if (insn)
				insn->opcode = insn->opcode | (((val.lo) & 0xfLL) << 9LL) | ((((val.lo >> 4LL)) & 0xffffLL) << 19LL);
		}
		else if (mnemo->ext.format==ENTER) {
			if (insn) {
				switch(i) {
				case 0:
					insn->opcode = insn->opcode | ((val.lo & 0xfLL) << 8LL);
					break;
				case 1:
					insn->opcode = insn->opcode | (((-val.lo >> 3LL) & 0xffffffffLL) << 12LL);
					break;
				}
			}
		}
		else if (mnemo->ext.format==LEAVE) {
			if (insn) {
				switch(i) {
				case 0:
					insn->opcode = insn->opcode | ((val.lo & 0xfLL) << 12LL);
					break;
				case 1:
					insn->opcode = insn->opcode | (((val.lo >> 3LL) & 0xffffffLL) << 16LL);
					break;
				}
			}
		}
		else if (mnemo->ext.format==RIS) {
			if (insn) {
				if (i==1) {
					insn->opcode = insn->opcode | ((val.lo & 0xffffffLL) << 16LL);
				}
				else if (i==2) {
					insn->opcode = insn->opcode | ((val.lo & 0x7LL) << 13LL);
				}			
			}
		}
		else if (mnemo->ext.format==RISM) {
			if (insn) {
				if (i==1) {
					insn->opcode = insn->opcode | (((val.lo >> 21LL) & 0x7fffffLL) << 17LL);
				}
				else if (i==2) {
					insn->opcode = insn->opcode | ((val.lo & 0x7LL) << 13LL);
				}			
			}
		}
		else if (mnemo->ext.format==RISH) {
			if (insn) {
				if (i==1) {
					insn->opcode = insn->opcode | (((val.lo >> 42LL) & 0x7fffffLL) << 17LL);
				}
				else if (i==2) {
					insn->opcode = insn->opcode | ((val.lo & 0x7LL) << 13LL);
				}			
			}
		}
		else if (mnemo->ext.format==RIL || mnemo->ext.format==RTDI) {
		}
		else if (mnemo->ext.format==REP) {
		}
		else if (mnemo->ext.format==SYNC) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0x7ffffLL) << 8LL);
		}
		else {
			/*
			if (!is_nbit(hval,80)) {
				isize = (8<<16)|(8<<8)|6;
				if (modifier2)
					*modifier2 = ((hval.hi >> 16LL) << 9LL) | EXIM;
				if (modifier)
					*modifier = ((hval.hi & 0xffffLL) << 48LL) | 
						((val.lo >> 25LL) << 9LL) | EXI56 | ((val.lo >> 24LL) & 1LL);
			}
			else
			if (!is_nbit(hval,64)) {
				if (modifier)
					*modifier = ((hval.hi & 0xffffLL) << 48LL) | 
						((val.lo >> 25LL) << 9LL) | EXI56 | ((val.lo >> 24LL) & 1LL);
				isize = (8<<8)|6;
			}
			else
			*/
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0xffLL) << 23LL) | (((val.lo >> 8LL) & 0x7fLL) << 33LL);
		}
	}
	else {
		if (mnemo->ext.format==SI) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 19LL);
		}
		else if (mnemo->ext.format==ATOM) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0xffffffLL) << 7LL);
		}
		else if (mnemo->ext.format==DIRECT) {
			isize = encode_direct(insn, hval, op->mask, i, pc, sec, ip);
		}
		else if (mnemo->ext.format==CSRI) {
			isize = 5;
			if (i==1) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 16);
			}
			else if (i==2) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0xffLL) << 23LL) | (((val.lo >> 8LL) & 0x3fLL) << 32LL);
			}
		}
		else if (mnemo->ext.format == RTDR) {
			if (insn) {
				if (i==1)
					insn->opcode = insn->opcode | (((val.lo >> 3LL) & 0x3ffffLL) << 22LL);
				else if (i==2)
					insn->opcode = insn->opcode | ((val.lo & 0xfLL) << 7LL);
			}
		}
		else if (mnemo->ext.format==CSR) {
			cpu_error(2);
		}
		else if (mnemo->ext.format==SHIFTI) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 24LL);
		}
		else if (mnemo->ext.format==RI6) {
			if (insn)
				insn->opcode = insn->opcode | ((val.lo & 0x3fLL) << 24LL);
		}
		else if (mnemo->ext.format==J2) {
			if (insn)
				insn->opcode = insn->opcode | (((val.lo) & 0xfLL) << 9LL) | ((((val.lo) >> 4LL) & 0xffffLL) << 19LL);
		}
		else if (mnemo->ext.format==R2) {
			if (mnemo->ext.opcode==0x5D) {	// SLLH
				if (insn)
					insn->opcode = insn->opcode | RB((val.lo >> 4LL) & 0x1fLL);
			}
			else {
				if (insn)
					insn->opcode = insn->opcode | RB(val.lo);
			}
		}
		else if (mnemo->ext.format==BFR3RI || mnemo->ext.format==BFR3IR || mnemo->ext.format==BFR3II) {
			isize = 5;
			if (i==2) {
				if (insn)
					insn->opcode = insn->opcode | BFOFFS(val.lo);
			}
			else if (i==3)
				if (insn)
					insn->opcode = insn->opcode | BFWID(val.lo);
		}
		else if (mnemo->ext.format==RIS) {
			if (insn) {
				if (i==1) {
					insn->opcode = insn->opcode | ((val.lo & 0xffffffLL) << 16LL);
				}
				else if (i==2) {
					insn->opcode = insn->opcode | ((val.lo & 0x7LL) << 13LL);
				}			
			}
		}
		else if (mnemo->ext.format==RISM) {
			if (insn) {
				if (i==1) {
					insn->opcode = insn->opcode | (((val.lo >> 21LL) & 0x7fffffLL) << 17LL);
				}
				else if (i==2) {
					insn->opcode = insn->opcode | ((val.lo & 0x7LL) << 13LL);
				}			
			}
		}
		else if (mnemo->ext.format==RISH) {
			if (insn) {
				if (i==1) {
					insn->opcode = insn->opcode | (((val.lo >> 42LL) & 0x7fffffLL) << 17LL);
				}
				else if (i==2) {
					insn->opcode = insn->opcode | ((val.lo & 0x7LL) << 13LL);
				}			
			}
		}
		else if (mnemo->ext.format==RI || mnemo->ext.format==RIV ||
			mnemo->ext.format==RIM || mnemo->ext.format==RIMV) {
			isize = encode_immed_RI(insn, val, i, pc, sec, ip);
		}
		else if (mnemo->ext.format==LDI) {
			isize = encode_immed_LDI(insn, val, i);
		}
		else if (mnemo->ext.format==RIL) {
		}
		else if (mnemo->ext.format==RII) {
			if (i==2) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 23LL);
			}
			else if (i==3) {
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0x7fLL) << 30LL);
			}
		}
		else if (mnemo->ext.format==REP) {
		}
		else {
			if (op->type & OP_IMM) {
				if (!is_nbit(val,16LL))
					goto j2;
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0xffLL) << 23LL) || (((val.lo >> 8LL) & 0xffLL) << 32LL);
				return (isize);
			}
			else {
j2:
				if (insn)
					insn->opcode = insn->opcode | ((val.lo & 0xffLL) << 8LL);
			}
		}
	}
	return (isize);
}

static int encode_pred(instruction_buf* insn, mnemonic* mnemo, operand* op, int64_t val, int* isize, int i)
{
	*isize = 5;

	TRACE("enpred ");
	if (op->type==OP_PREDSTR) {
		if (insn) {
			printf("predval2=%I64x\n", val);
			insn->opcode |= ((val & 0xffffLL) << 22LL);
		}
	}	
	return (*isize);
}

static int encode_vmask(instruction_buf* insn, mnemonic* mnemo, operand* op, int64_t val, int* isize, int i)
{
	*isize = 5;

	TRACE("evm ");
	if (op->type==OP_VMSTR) {
		if (insn) {
			insn->opcode |= ((val & 0x3fffffLL) << 5LL) | (((val >> 22LL) & 0x3LL) << 29LL);
		}
	}	
	return (*isize);
}

/* Encode condional branch. */

/* The value passed into encode_branch_B is pre-cooked for ordinary relative
   branches, or split target branches using an instruction block number and
   block relative displacement. These have been calculated by
   encode_qupls_instruction.
   Registers are already encoded by a generic function, what's left to encode
   is constant values.
*/
static size_t encode_branch_B(instruction_buf* insn, operand* op, int64_t val, int i, unsigned int flags)
{
	uint64_t tgt;
	thuge hg;
	size_t isize = 5;
	
	if (op->type == OP_IMM) {
		switch(i) {
		case 0:
			hg = huge_from_int(val);
			encode_ipfx(&insn->pfxa, hg, 0);
			break;
		case 1:
			if (flags & FLG_UI6) {
				if (insn)
					insn->opcode = insn->opcode | RB(val & 0x3f);
			}
			else {
				hg = huge_from_int(val);
				encode_ipfx(&insn->pfxb, hg, 1);
			}
			break;
			/* For BRANCH_INO the target field is split in two, one containing the
			   instruction slot number, 4 bits, and a second field containing the
			   block relative displacement. The value is already composed properly.
			*/
#ifdef BRANCH_PGREL
		case 2:
	  	if (insn) {
  			tgt = (((val & 0x1fff0LL) >> 4LL) << 27LL);
  			insn->opcode |= tgt;
  			tgt = ((val & 3LL) << 11LL);
  			insn->opcode |= tgt;
  			tgt = (((val & 0xfLL) >> 2LL) << 25LL);
  			insn->opcode |= tgt;
			}
			break;
#endif
#ifdef BRANCH_INO
		case 2:
	  	if (insn) {
  			tgt = (((val & 0x1fff0LL) >> 4LL) << 27LL);
  			insn->opcode |= tgt;
  			tgt = ((val & 3LL) << 11LL);
  			insn->opcode |= tgt;
  			tgt = (((val & 0xfLL) >> 2LL) << 25LL);
  			insn->opcode |= tgt;
			}
			break;
#endif
#ifdef BRANCH_PCREL		
		case 2:
	  	if (insn) {
  			tgt = (((val & 0x3ffffLL)) << 22LL);
  			insn->opcode |= tgt;
  		}
			break;
#endif			
		}
	}
	return (isize);
}

/* Encode uncondional branch, has wider target field. 
	 The incoming value is cooked to the proper format.
*/

static void encode_branch_BL2(instruction_buf* insn, operand* op, int64_t val, int i)
{
	uint64_t tgt;

	if (op->type == OP_IMM) {
		if (insn) {
			switch(i) {
			case 1:
  			tgt = ((val & 0x3fffffffLL) << 10LL);
  			insn->opcode |= tgt;
		  	break;
			}
		}
	}
}

static int encode_J2(instruction_buf* insn, operand* op, int64_t val, int i, int* isize)
{
	thuge hg;

	hg = huge_from_int(val);
  if (op->type==OP_IMM) {
  	if (insn) {
  		uint64_t tgt;
  		//*insn |= CA(mnemo->ext.format==B2 ? 0x7 : 0x0);
  		tgt = (((val) & 0xfLL) << 9LL) | (((val >> 4LL) & 0xffffLL) << 19LL);
  		insn->opcode |= tgt;
  	}
  	if (!is_nbit(hg,29LL)) {
  		encode_ipfx(&insn->pfxb,hg,1);
  		*isize = insn->pfxb.size + 5;
  	}
  	return (1);
	}
  if (op->type==OP_REGIND) {
  	if (insn) {
  		uint64_t tgt;
  		insn->opcode |= RA(op->basereg);
    		tgt = (((val) & 0xfLL) << 9LL) | ((val & 0x7ffffffLL) << 19LL);
  		insn->opcode |= tgt;
  	}
  	return (1);
  }
  return (0);
}

/* Evaluate branch operands excepting GPRs which are handled earlier.
	Returns 1 if the branch was processed, 0 if illegal branch format.
*/
static int encode_branch(instruction_buf* insn, mnemonic* mnemo, operand* op, int64_t val, int* isize, int i)
{
	uint64_t tgt;
	*isize = 5;

	TRACE("encb:");
	switch(mnemo->ext.format) {

	case B:
		*isize = encode_branch_B(insn, op, val, i, mnemo->ext.flags);
  	return (1);

	case BI:
		*isize = encode_branch_B(insn, op, val, i, mnemo->ext.flags);
  	return (1);

	case B2:
		encode_branch_BL2(insn, op, val, i+1);
		*isize = insn->size;
  	return (1);

	case BZ:
		*isize = encode_branch_B(insn, op, val, i+1, mnemo->ext.flags);
  	return (1);

	case BL2:
		encode_branch_BL2(insn, op, val, i);
		*isize = insn->size;
  	return (1);

	case J2:
		if (encode_J2(insn, op, val, i, isize))
			return (1);
	  break;

	case JL2:
  	if (op->type==OP_IMM) {
	  	if (insn) {
    		uint64_t tgt;
    		tgt = (((val >> 1LL) & 0x1fffLL) << 11LL) | (((val >> 14LL) & 0x7ffffLL) << 29LL);
    		insn->opcode |= tgt;
	  	}
	  	return (1);
	  }
	  if (op->type==OP_REGIND) {
	  	if (insn) {
	  		uint64_t tgt;
	  		insn->opcode |= RC(op->basereg);
	    		tgt = (((val >> 1LL) & 0x1fffLL) << 11LL) | (((val >> 14LL) & 0x7ffffLL) << 29LL);
	  		insn->opcode |= tgt;
	  	}
	  	return (1);
	  }
	  break;

	case J3:
		*isize = 5;
		/*
	  if (op->type==OP_REGIND) {
	  	if (insn) {
	  		uint64_t tgt;
	  		*insn |= CA(op->basereg & 0x7);
	  		tgt = (((val >> 1LL) & 0x1fLL) << 9LL) | (((val >> 6LL) & 0x1fffLL) << 19LL);
	  		*insn |= tgt;
	  	}
	  	return (1);
	  }
		else 
		*/
		if (op->type == OP_IMM) {
			if (insn) {
				switch(i) {
				case 1:
			  	if (insn) {
			  		uint64_t tgt;
			  		tgt = (((val >> 1LL) & 0x1fLL) << 9LL) | (((val >> 6LL) & 0x1fffLL) << 19LL);
			  		insn->opcode |= tgt;
			  	}
			  	break;
				}
			}
	  	return (1);
		}
		break;

	case JL3:
		*isize = 5;
		/*
	  if (op->type==OP_REGIND) {
	  	if (insn) {
	  		uint64_t tgt;
	  		*insn |= CA(op->basereg & 0x7);
	  		tgt = (((val >> 1LL) & 0x1fLL) << 9LL) | (((val >> 6LL) & 0x1fffLL) << 19LL);
	  		*insn |= tgt;
	  	}
	  	return (1);
	  }
		else
		*/
		if (op->type == OP_IMM) {
			if (insn) {
				switch(i) {
				case 2:
			  	if (insn) {
			  		uint64_t tgt;
			  		tgt = (((val >> 1LL) & 0x1fLL) << 9LL) | (((val >> 6LL) & 0x1fffLL) << 19LL);
			  		insn->opcode |= tgt;
			  	}
			  	break;
				}
			}
	  	return (1);
		}
		break;

  }
  TRACE("ebv0:");
  return (0);
}

/* Encode scaled, indexed, addressing for load / store operations.
*/
static size_t encode_scndx(
	instruction *ip,
	instruction_buf* insn,
	operand* op,
	thuge val,
	int constexpr,
	int i,
	int pass
)
{
	size_t isize = 5;
  mnemonic *mnemo = &mnemonics[ip->code];

	TRACE("Etho6:");
	if (insn) {
		if (i==0)
			insn->opcode |= (RT(op->basereg));
		else if (i==1) {
			insn->opcode |= (RA(op->basereg));
			/* *insn |= ((val & 0xffLL) << 21LL); */
			insn->opcode |= RB(op->ndxreg);
			if (op->scale==-1) {
				switch(mnemo->ext.defsize) {
				case SZ_BYTE:	insn->opcode |= S(0); break;
				case SZ_WYDE: insn->opcode |= S(1); break;
				case SZ_TETRA: insn->opcode |= S(2); break;
				case SZ_OCTA: insn->opcode |= S(3); break;
				}
			}
			else {
				switch(op->scale) {
				case 1:	insn->opcode |= S(0); break;
				case 2: insn->opcode |= S(1); break;
				case 4: insn->opcode |= S(2); break;
				case 8: insn->opcode |= S(3); break;
				default: ;
				}
			}
		}
	}
	if (pass==1)
		ip->ext.const_expr = constexpr;
	if ((constexpr && pass==1) || ip->ext.const_expr) {
		/* 	db is NULL for the first encode_thor_operands 
				If there is a constant during the first pass, then it should remain the
				same during the second pass. The size of the constant will be known.
		*/
		if (val.lo != 0LL || val.hi != 0LL) {
			encode_ipfx(&insn->pfxb,val,1);
		}
	}
	else {
		encode_ipfx(&insn->pfxb,val,1);
	}
	return (isize);
}

/* Encode scaled indexed addressing for Jump instructions.
*/
static size_t encode_jscndx(
	instruction *ip,
	instruction_buf* insn,
	operand* op,
	thuge val,
	int constexpr,
	int i,
	int pass
)
{
	size_t isize = 5;

	TRACE("E_jscndx:");
	if (insn) {
		if (i==1)
			insn->opcode |= (RA(op->basereg));
		else if (i==2) {
			insn->opcode |= (RB(op->ndxreg));
		}
	}
	if (pass==1)
		ip->ext.const_expr = constexpr;
	if ((constexpr && pass==1) || ip->ext.const_expr) {
		/* 	db is NULL for the first encode_thor_operands 
				If there is a constant during the first pass, then it should remain the
				same during the second pass. The size of the constant will be known.
		*/
		if (1 || val.lo != 0LL || val.hi != 0LL) {
			encode_ipfx(&insn->pfxb,val,1);
		}
	}
	else {
		encode_ipfx(&insn->pfxb,val,1);
	}
	return (isize);
}

static size_t encode_regind(
	instruction *ip,
	instruction_buf* insn,
	operand* op,
	thuge val,
	int constexpr,
	int i,
	int pass
)
{
	size_t isize = 5;

	TRACE("Etho5:");
	if (insn) {
		if (i==0)
			insn->opcode |= (RT(op->basereg));
		else if (i==1) {
			insn->opcode |= (RA(op->basereg));
			insn->opcode |= (val.lo & 0x1fffffLL) << 19LL;
		}
	}
	return (isize);
}

static size_t encode_regind_disp(
	instruction *ip,
	instruction_buf* insn,
	operand* op,
	thuge val,
	int constexpr,
	int i,
	int pass
)
{
	size_t isize = 5;

	TRACE("Etho5:");
	if (insn) {
		if (i==0)
			insn->opcode |= (RT(op->basereg));
		else if (i==1) {
			insn->opcode |= (RA(op->basereg));
			insn->opcode |= (val.lo & 0x1fffffLL) << 19LL;
		}
	}
	if (pass==1)
		ip->ext.const_expr = constexpr;
	if ((constexpr && pass==1) || ip->ext.const_expr) {
		if (op->value || val.lo != 0LL || val.hi != 0LL) {
			encode_ipfx(&insn->pfxb,val,1);
		}
	}
	else {
		if (op->value)
			encode_ipfx(&insn->pfxb,val,1);
	}
	return (isize);
}

/* Create additional operand for split target branches. Needed for either
	 memory page relative addressing or instruction block relative addressing.
*/

static void create_split_target_operands(instruction* ip, mnemonic* mnemo)
{
	return;
	/* dead code */
	switch(mnemo->ext.format) {
	case B:
	case BI:
		TRACE("Fmtb:");
		if (ip->op[2]) {
			ip->op[3] = new_operand();
			memcpy(ip->op[3], ip->op[2], sizeof(operand));
			ip->op[3]->number = 3;
			ip->op[3]->attr = REL_PC;
			ip->op[3]->value = copy_tree(ip->op[2]->value);
		}
		break;
	case BZ:
	case BL2:
		TRACE("Fmtb:");
		if (ip->op[1]) {
			ip->op[2] = new_operand();
			memcpy(ip->op[2], ip->op[1], sizeof(operand));
			ip->op[2]->number = 2;
			ip->op[2]->attr = REL_PC;
			ip->op[2]->value = copy_tree(ip->op[1]->value);
		}
		break;
	case B2:
		TRACE("Fmtb:");
		if (ip->op[0]) {
			ip->op[1] = new_operand();
			memcpy(ip->op[1], ip->op[0], sizeof(operand));
			ip->op[1]->number = 1;
			ip->op[1]->attr = REL_PC;
			ip->op[1]->value = copy_tree(ip->op[0]->value);
		}
		break;
	}
}

/* Encode any instruction qualifiers.
   These include: operation size code.
   Currently under construction.
*/
static void encode_qualifiers(instruction* ip, uint64_t* insn)
{
	int i, j;
	int setsz = 0;
  mnemonic *mnemo = &mnemonics[ip->code];

	TRACE("eq ");
	if (insn == NULL)
		return;
//	return;

	for (i = 0; ip->qualifiers[i] && i < MAX_QUALIFIERS; i++) {
//	for (i = 0; i < MAX_QUALIFIERS; i++) {
//		if (qual[i]==NULL || qual_len[i] <= 0)
//			continue;
//		printf("ip->qualifiers:%.50s\n", ip->qualifiers[i]);
		for (j = 0; j < sizeof(qualifiers_code)/sizeof(int); j++) {
			if (strnicmp(ip->qualifiers[i],qualifiers[j],7)==0) {
				/*
				if (qualifiers_code[j] & 0x80) {
					switch(mnemo->ext.format) {
					case SCNDX:
						if (qualifiers_code[j]==0x84)	// FAF store
							*insn |= 0x400000000LL;
						*insn |= (uint64_t)(qualifiers_code[j] & 3) << 12LL;
						break;
					case REGIND:
					case DIRECT:
						*insn |= (uint64_t)(qualifiers_code[j] & 3) << 37LL;
						break;
					}
				}
				*/
				// else size code
				/* Size code requires some more thought
				else {
					if (mnemo->ext.size != SZ_UNSIZED) {
						setsz = 1;
						if (mnemo->ext.format==SCNDX)
							*insn |= (uint64_t)(qualifiers_code[j]) << 9LL;
						else
							*insn |= (uint64_t)SZ(qualifiers_code[j]);
					}
				}
				*/
				break;
			}
		}
	}
	/*
	if (mnemo->ext.size != SZ_UNSIZED && !setsz)
		*insn |= (uint64_t)SZ(mnemo->ext.defsize);
	*/

}

/* Detect if the target operand of a branch is being processed.
*/
static int is_branch_target_oper(mnemonic *mnemo, int i, int* opt)
{
	if (!is_branch(mnemo))
		return (0);
	if (opt==NULL)
		return (0);
	*opt = 0;
	switch(mnemo->ext.format) {
	case B:
	case BI:
		*opt = 5;
		return (i==2 || i==3);
	case B2:
		return (i==0);
	case BL2:
		return (i==1 || i==2);
	}
	return (0);
}

/* evaluate expressions and try to optimize instruction,
   return size of instruction 

   Since the instruction may contain a modifier which varies in size, both the
   size of the instruction and the size of the modifier is returned. The size
   of the instruction is in the return value, the size of the 
   modifier is passed back in the modifier constant. The total size may be 
   calculated using a simple shift and sum.
*/
size_t encode_qupls_instruction(instruction *ip,section *sec,taddr pc,
  uint64_t *modifier1, uint64_t *modifier2, instruction_buf* insn, dblock *db)
{
  mnemonic *mnemo = &mnemonics[ip->code];
  size_t isize = 5;
  static taddr prev_pc = 0;
  int i;
  operand op;
	int constexpr;
	int reg = 0;
	char vector_insn = 0;
	char has_vector_mask = mnemo->ext.flags & FLG_MASK;
	thuge op1val, wval;
	char ext;
	uint64_t szcode;
	int setsz = 0;
	int called_makereloc = 0;
	int bropt = 0;

	TRACE("Eto:");
	if (modifier1)
		*modifier1 = 0;
	if (modifier2)
		*modifier2 = 0;

//  ext = ip->qualifiers[0] ?
//             tolower((unsigned char)ip->qualifiers[0][0]) : '\0';
//  szcode = 
//	  ((mnemo->ext.size) == SZ_UNSIZED) ?
//    0 : lc_ext_to_size(ext) < 0 ? mnemo->ext.defsize : lc_ext_to_size(ext);

	//isize = mnemo->ext.len;
	/*
  if (insn != NULL) {
    *insn = mnemo->ext.opcode;
    *insn |= SZ(szcode);
   }
	*/

	isize = mnemo->ext.len;
  if (insn != NULL) {
  	insn->opcode_size = mnemo->ext.len;
    insn->opcode = mnemo->ext.opcode;
  	insn->size = mnemo->ext.len;
  	insn->short_opcode = mnemo->ext.short_opcode;
  }
	if (mnemo->ext.format==PADI) {
		isize = 64LL - (pc & 0x3fLL);
		insn->size = isize;
	}
//	encode_qualifiers(ip, insn);


	if (modifier1)
		*modifier1 = 0;

	/* Create additional operand for split target branches */
#ifdef BRANCH_PGREL
	create_split_target_operands(ip, mnemo);
#endif
#ifdef BRANCH_INO
	create_split_target_operands(ip, mnemo);
#else
	create_split_target_operands(ip, mnemo);
#endif

	// Detect a vector instruction
  for (i=0; i<MAX_OPERANDS && ip->op[i]!=NULL; i++) {
  	if (ip->op[i]->type==OP_VREG) {
  		vector_insn = 1;
  		break;
  	}
	}

  for (i=0; i<MAX_OPERANDS && ip->op[i]!=NULL; i++) {
    operand *pop;
    int reloctype;
    taddr hval;
    thuge val;

		TRACE("F");
    op = *(ip->op[i]);	/* convenience */
    /* reflect the format back into the operand */
    ip->op[i]->number = i;
    op.number = i;
    op.format = mnemo->ext.format;
    
    /* special case: operand omitted and use this operand's type + 1
         for the next operand */
    /*
    if (op.type == NEXT) {
      op = *(ip->op[++i]);
      op.type = mnemo->operand_type[i-1] + 1;
    }
	*/
		constexpr = 1;
		called_makereloc = 0;
    if ((reloctype = get_reloc_type(&op)) != REL_NONE) {
      if (db != NULL) {
        val = make_reloc(reloctype,&op,sec,pc,&db->relocs,&constexpr);
        called_makereloc = 1;
      }
      else {
      	val.lo = val.hi = 0;
        if (!eval_expr(op.value,&val.lo,sec,pc)) {
        	if (val.lo & 0x8000000000000000LL)
        		val.hi = 0xFFFFFFFFFFFFFFFFLL;
        	if (is_branch_target_oper(mnemo, i, &bropt))
        	{
	          if (reloctype == REL_PC)
	          	val = calc_branch_disp(val, pc, bropt);
		 			}
        }
        else {
        	if (val.lo & 0x8000000000000000LL)
        		val.hi = 0xFFFFFFFFFFFFFFFFLL;
        }
      }
    }
    else {
//      if (!eval_expr(op.value,&val,sec,pc))
      if (!eval_expr(op.value,&val.lo,sec,pc)) {
      	if (val.lo & 0x8000000000000000LL)
      		val.hi = 0xFFFFFFFFFFFFFFFFLL;
        if (insn != NULL) {
/*	    	printf("***A4 val:%lld****", val);
          cpu_error(2);  */ /* constant integer expression required */
        }
      }
    }
  	if (is_branch_target_oper(mnemo, i, &bropt)) {
//						eval_expr_huge(op.value,&val);
			//val = hsub(val,huge_from_int(pc));
      if (reloctype == REL_PC && !called_makereloc)
      	val = calc_branch_disp(val, pc, bropt);
//			val = hsub(wval,huge_from_int(pc));
		}

		if (i==1) {
			op1val = val;
		}

		TRACE("Ethof:");
    if (db!=NULL && op.type==OP_REGIND && op.attr==REL_NONE) {
			TRACE("Ethof1:");
      if (op.basereg == sdreg) {  /* is it a small data reference? */
				TRACE("Ethof3:");
        fix_reloctype(db,REL_SD);
/*        else if (reg == sd2reg)*/  /* EABI small data 2 */
/*          fix_reloctype(db,REL_PPCEABI_SDA2); */
			}
    }

		TRACE("Etho2:");
		if (op.type==OP_REG || op.type==OP_VREG) {
			encode_reg(insn, &op, mnemo, i);
		}
		else if (op.type==OP_REG6) {
			encode_reg6(insn, &op, mnemo, i);
		}
		else if (mnemo->operand_type[i]==OP_LK) {
			if (insn) {
 				switch(mnemo->ext.format) {
 				case JL3:
 				case BL:
 				case RTS:
 					if (i==0)
 						insn->opcode = insn->opcode | RA(op.basereg);
 					break;
 				case JSCNDX:
 				case JL2:
 				case BL2:
 					if (i==0)
 						insn->opcode = insn->opcode | (((op.basereg) & 7LL) << 7LL);
 					break;
				default:
 					cpu_error(18);
				}				
			}
		}
		/*
    else if ((mnemo->operand_type[i]&OP_IMM7) && op.type==OP_IMM) {
 			if (!is_nbit(val, 7)) {
 				cpu_error(12,val,-64,64);
 			}
 			if (insn) {
 				switch(mnemo->ext.format) {
 				case R2:
 					if (i==2)
 						*insn = *insn| (TB(2|((val>>6) & 1))) | (RB(val & 0x3f));
 					break;
 				case R3:
 					if (i==2)
 						*insn = *insn| (TB(2|((val>>6) & 1))) | (RB(val & 0x3f));
 					else if (i==3)
 						*insn = *insn| (TC(2|((val>>6) & 1))) | (RC(val & 0x3f));
 					break;
 				case BL:
 					if (i==2)
 						*insn = *insn| (TB(2|((val>>6) & 1))) | (RB(val & 0x3f));
 					break;
 				case B:
 				}
 			}
    }
    */
    else if (((mnemo->operand_type[i])&OP_IMM) && (op.type==OP_IMM) && !is_branch(mnemo)) {
			TRACE("Etho3:");
			isize = encode_immed(insn, mnemo, &op, val, constexpr, i, vector_insn, pc, sec, ip);
    }
    else if (encode_branch(insn, mnemo, &op, val.lo, &isize, i)) {
			TRACE("Etho4:");
    	;
    }
    else if (mnemo->operand_type[i]==OP_PREDSTR) {
    	encode_pred(insn, mnemo, &op, val.lo, &isize, i);
    }
    else if (mnemo->operand_type[i]==OP_VMSTR) {
    	encode_vmask(insn, mnemo, &op, val.lo, &isize, i);
    }
    else if ((mnemo->operand_type[i]&OP_REGIND)==OP_REGIND && op.type==OP_REGIND)
			isize = encode_regind(ip, insn, &op, val, constexpr, i, db==NULL);
    else if ((mnemo->operand_type[i]&OP_REGIND_DISP)==OP_REGIND_DISP && op.type==OP_REGIND_DISP)
			isize = encode_regind_disp(ip, insn, &op, val, constexpr, i, db==NULL);
    else if ((mnemo->operand_type[i]&OP_SCNDX)==OP_SCNDX && op.type==OP_SCNDX)
			isize = encode_scndx(ip, insn, &op, val, constexpr, i, db==NULL);
    else if ((mnemo->operand_type[i]&OP_IND_SCNDX)==OP_IND_SCNDX && op.type==OP_IND_SCNDX)
			isize = encode_jscndx(ip, insn, &op, val, constexpr, i, db==NULL);
	}
	
	TRACE("G");
	return (isize);
}

/* Test if the instruction will fit into the block.
   Returns true if the instruction will fit.
*/
static int will_fit_in_block(taddr pc, size_t sz)
{
#ifdef SUPPORT_IBH
	taddr npc = pc + sz;
	return ((npc & ~0x3fLL)==(pc & ~0x3fLL)) && ((npc & 0x3fLL) <= 60LL);
#else
	return (1);
#endif
}

static int is_last_in_block(taddr pc)
{
	return ((pc & 0x3fLL) >= 59LL);
}

static void convert_opcode_to_r3(instruction_buf* insn, int64_t* pOpcode)
{
	int64_t op;

	switch(insn->opcode & 0x3fLL) {
	case 4LL:	// ADDI
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(2LL);		// R3 opcode
		op |= RB(51LL);
		op |= R3FUNC(4LL);
		break;
	case 8LL:	// ANDI
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(2LL);		// R3 opcode
		op |= RB(51LL);
		op |= R3FUNC(8LL);
		break;
	case 9LL:	// ORI
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(2LL);		// R3 opcode
		op |= RB(51LL);
		op |= R3FUNC(9LL);
		break;
	case 10LL:	// EORI
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(2LL);		// R3 opcode
		op |= RB(51LL);
		op |= R3FUNC(10LL);
		break;
	case 11LL:	// CMPI
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(2LL);		// R3 opcode
		op |= RB(51LL);
		op |= R3FUNC(3LL);
		break;
	case 19LL:	// CMPUI
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(2LL);		// R3 opcode
		op |= RB(51LL);
		op |= R3FUNC(6LL);
		break;
	// Loads
	case 64LL:	// LDB
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(79LL);		// LD indexed opcode
		op |= RB(51LL);
		op |= FUNC5(0LL);
		break;
	case 65LL:	// LDBU
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(79LL);		// LD indexed opcode
		op |= RB(51LL);
		op |= FUNC5(1LL);
		break;
	case 66LL:	// LDW
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(79LL);		// LD indexed opcode
		op |= RB(51LL);
		op |= FUNC5(2LL);
		break;
	case 67LL:	// LDWU
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(79LL);		// LD indexed opcode
		op |= RB(51LL);
		op |= FUNC5(3LL);
		break;
	case 68LL:	// LDT
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(79LL);		// LD indexed opcode
		op |= RB(51LL);
		op |= FUNC5(4LL);
		break;
	case 69LL:	// LDTU
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(79LL);		// LD indexed opcode
		op |= RB(51LL);
		op |= FUNC5(5LL);
		break;
	case 70LL:	// LDO
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(79LL);		// LD indexed opcode
		op |= RB(51LL);
		op |= FUNC5(6LL);
		break;
	// Stores
	case 80LL:	// STB
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(87LL);		// ST indexed opcode
		op |= RB(51LL);
		op |= FUNC5(0LL);
		break;
	case 81LL:	// STW
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(87LL);		// ST indexed opcode
		op |= RB(51LL);
		op |= FUNC5(1LL);
		break;
	case 82LL:	// STT
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(87LL);		// ST indexed opcode
		op |= RB(51LL);
		op |= FUNC5(2LL);
		break;
	case 83LL:	// STO
		op = insn->opcode & 0x3ff80LL;	// Keep Ra,Rt
		op |= OPC(87LL);		// ST indexed opcode
		op |= RB(51LL);
		op |= FUNC5(3LL);
		break;
	}
}

/* Calculate the size of the current instruction; must be identical
   to the data created by eval_instruction. */
size_t instruction_size(instruction *ip,section *sec,taddr pc)
{
  mnemonic *mnemo = &mnemonics[ip->code];
  uint64_t modifier1, modifier2;
  instruction_buf insn;
	taddr apc;

	TRACE("is "); 
	modifier1 = 0;
	modifier2 = 0;
	size_t sz = 0;

	memset(&insn,0,sizeof(insn));
	sz = encode_qupls_instruction(ip,sec,pc,&modifier1,&modifier2,&insn,NULL);
	sz = sz + (modifier1 >> 48LL) + (modifier2 >> 48LL);
#ifdef SUPPORT_PFX_IMM
	sz = sz + insn.pfxa.size + insn.pfxb.size + insn.pfxc.size;
#endif
 	if (!will_fit_in_block(pc, sz) && !mnemo->ext.format==PADI)
	{
		apc = (pc + 64LL) & ~0x3fLL;		// align IP to next block
		sz = apc - pc + sz;
	}
	if (0 && sz > 80) {
		printf("mod1: %I64d\n", modifier1 >> 48LL);
		printf("mod2: %I64d\n", modifier2 >> 48LL);
		exit(21);
	}
	insn_sizes1[sz1ndx++] = sz;
	TRACE2("isize=%d ", sz);
  return (sz);
}

static unsigned char* encode_pfx(unsigned char *d, postfix_buf* pfx, uint8_t which)
{
	thuge val = pfx->val;
	int size = pfx->size;
	uint64_t op;

	switch(which) {
	case 0: op = 56LL; break;
	case 1: op = 60LL; break;
	case 2: op = 48LL; break;
	default:
		printf("Illegal postfix\n");
		exit(0);
	}
	switch(size) {
	case 5:
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.lo);
    qupls_insn_count++;
		break;
	case 10:
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.lo);
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.lo >> 32LL);
    qupls_insn_count+=2;
		break;
	case 15:
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.lo);
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.lo >> 32LL);
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.hi);
    qupls_insn_count+=3;
		break;
	case 20:
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.lo);
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.lo >> 32LL);
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.hi);
    d = setval(0,d,1,op);
    d = setval(0,d,4,val.hi >> 32LL);
    qupls_insn_count+=4;
		break;
	default:
		printf("illegal postfix size.\n");
	}
	return (d);
}

static char* out_si_imm(taddr pc, taddr* pco, int64_t imm, char *d)
{
	if (will_fit_in_block(pc,5)) {
		d = setval(0,d,5,imm);
		qupls_insn_count++;
		pc += 5;
	}
	else {
		d = setval(0,d,4,0x00003cff);
		d = setval(0,d,5,imm);
		qupls_insn_count+=2;
		pc &= 0xffffffffffffffc0LL;
		pc += 64LL;
	}
	if (pco)
		*pco = pc;
	return (d);
}

/* Convert an instruction into a DATA atom including relocations,
   when necessary. */
dblock *eval_instruction(instruction *ip,section *sec,taddr pc)
{
  mnemonic *mnemo = &mnemonics[ip->code];
  dblock *db = new_dblock();
  uint64_t modifier1, modifier2, pfxndx;
  instruction_buf insn;
  size_t sz, pfxsize, szd;
  size_t final_sz;
  size_t to_allocate;
  int bytes_remaining;
	// Trailer val records the position of the last instruction in the cache
	// line (instruction block).
  static int trailer_val = 0;
  taddr pcd, npc, last_pc;
  char* trailer = NULL;
	static int icnt = 0;
	static int grpcnt = 0;
	static taddr prev_pc = 0;
	static uint64_t prev_insn;
	int will_fit = 1;
	int has_imm = 0;
	int pc_wrapped = 0;
	int block_changed = 0;

	TRACE("ei ");
	modifier1 = 0;
	modifier2 = 0;
	memset(&insn,0,sizeof(insn));
	sz = encode_qupls_instruction(ip,sec,pc,&modifier1,&modifier2,&insn,NULL);
	sz = sz + (modifier1 >> 48LL) + (modifier2 >> 48LL);

	final_sz = sz;
  if (db) {
    uint8_t *d;
    unsigned char *d2;
    int i;

		d = db->data = mymalloc(5);
		db->size = 5;
		memset(&insn,0,sizeof(insn));
		encode_qupls_instruction(ip,sec,pc,&modifier1,&modifier2,&insn,db);
		insn_sizes2[sz2ndx] = db->size;

		// Output the code bytes.
    d = setval(0,d,db->size,insn.opcode);
   	qupls_insn_count++;
	  /* Debugging
		while (db->size < insn_sizes1[sz2ndx]) {
	    d = setval(0,d,5,0x9fLL);	// NOP
	    db->size += 5;
	    insn_count++;
		}	
		*/
		sz2ndx++;
		/* Finally, output the trailer (header) once an instruction will not fit at
		   the end of a block. The trailer is encoded as a debug breakpoint.
		*/
    qupls_byte_count += db->size;	/* and more stats */
  }
  return (db);
}


/* Create a dblock (with relocs, if necessary) for size bits of data. */
dblock *eval_data(operand *op,size_t bitsize,section *sec,taddr pc)
{
  dblock *db = new_dblock();
  thuge val;
  tfloat flt;
  int constexpr = 1;

	TRACE("ed ");
  if ((bitsize & 7) || bitsize > 64)
    cpu_error(9,bitsize);  /* data size not supported */
  /*
	if (!OP_DATAM(op->type))
  	ierror(0);
	*/
  db->size = bitsize >> 3;
  db->data = mymalloc(db->size);

  if (type_of_expr(op->value) == FLT) {
    if (!eval_expr_float(op->value,&flt))
      general_error(60);  /* cannot evaluate floating point */
/*
    switch (bitsize) {
      case 32:
        conv2ieee32(0,db->data,flt);
        break;
      case 64:
        conv2ieee64(0,db->data,flt);
        break;
      default:
        cpu_error(10);
        break;
    }
*/
  }
  else {
    val = make_reloc(get_reloc_type(op),op,sec,pc,&db->relocs,&constexpr);

    switch (db->size) {
      case 1:
        db->data[0] = val.lo & 0xff;
        break;
      case 2:
      case 4:
      case 8:
        setval(0,db->data,db->size,val.lo);
        break;
      default:
        ierror(0);
        break;
    }
  }

  return db;
}

/* To be inserted at the end of main() for debugging */

void at_end()
{
	int lmt = sz1ndx > sz2ndx ? sz2ndx : sz1ndx;
	int ndx;

	printf("Instructions: %d\n", qupls_insn_count);
	printf("Bytes: %d\n", qupls_byte_count);
	printf("Padding Bytes: %d\n", qupls_padding_bytes);
	printf("Header bytes: %d\n", qupls_header_bytes);
	printf("%f bytes per instruction\n", (double)(qupls_byte_count)/(double)(qupls_insn_count));
	/*
	for (ndx = 0; ndx < lmt; ndx++) {
		printf("%csz1=%d, sz2=%d\n", insn_sizes1[ndx]!=insn_sizes2[ndx] ? '*' : ' ', insn_sizes1[ndx], insn_sizes2[ndx]);
	}
	*/
}
/* return true, if initialization was successfull */
int init_cpu()
{
	TRACE("icpu ");
	qupls_insn_count = 0;
	qupls_byte_count = 0;
	qupls_padding_bytes = 0;
	qupls_header_bytes = 0;
	atexit(at_end);
  return (1);
}

/* return true, if the passed argument is understood */
int cpu_args(char *p)
{
//	atexit(at_end);
  abits = 32;
  if (strncmp(p, "-abits=", 7)==0) {
  	abits = atoi(&p[7]);
  	if (abits < 16)
  		abits = 16;
  	else if (abits > 64)
  		abits = 64;
  	return (1);
  }
  return (0);
}

static taddr read_sdreg(char **s,taddr def)
{
  expr *tree;
  taddr val = def;

	TRACE("rdsd ");
  *s = skip(*s);
  tree = parse_expr(s);
  simplify_expr(tree);
  if (tree->type==NUM && tree->c.val>=0 && tree->c.val<=63)
    val = tree->c.val;
  else
    cpu_error(13);  /* not a valid register */
  free_expr(tree);
  return val;
}


/* parse cpu-specific directives; return pointer to end of
   cpu-specific text */
char *parse_cpu_special(char *start)
{
	TRACE("pcs ");
  char *name=start,*s=start;

  if (ISIDSTART(*s)) {
    s++;
    while (ISIDCHAR(*s))
      s++;
    if (s-name==6 && !strncmp(name,".sdreg",6)) {
      sdreg = read_sdreg(&s,sdreg);
      return s;
    }
    else if (s-name==7 && !strncmp(name,".sd2reg",7)) {
      sd2reg = read_sdreg(&s,sd2reg);
      return s;
    }
    else if (s-name==7 && !strncmp(name,".sd3reg",7)) {
      sd3reg = read_sdreg(&s,sd3reg);
      return s;
    }
  }
  return start;
}

void init_instruction_ext(instruction_ext *ext)
{
	TRACE("iie ");
	if (ext) {
		ext->size = 0;
		ext->postfix_count = 0;
		ext->const_expr = 0;
	}
}