On 2023-11-18 12:27 p.m., MitchAlsup wrote:
> Robert Finch wrote:
>
>> On 2023-11-15 2:11 p.m., MitchAlsup wrote:
>>> Robert Finch wrote:
>>>
>>>> Decided to shelve Thor2024 and begin work on Thor2025. While
>>>> Thor2024 is very good there are a few issues with it. The ROB is
>>>> used to store register values and that is effectively a CAM. It is
>>>> not very resource efficient in an FPGA. I have been researching an
>>>> x86 OoO implementation
>>>> (https://www.stuffedcow.net/files/henry-thesis-phd.pdf ) done in an
>>>> FPGA and it turns out to be considerably smaller than Thor. There
>>>> are more efficient implementations for components than what is
>>>> currently in use.
>>>
>>>> Thor2025 will use a PRF approach although using a PRF seems large to
>>>> me.
>>> <
>>> I have a PRF design I could show you--way to big for comp.arch and
>>> with the requisite figures.
>>> <
>>>> To reduce the size and complexity of the register file, separate
>>>> register files will be used for float and integer operations, along
>>>> with separate register files for vector mask registers and
>>>> subroutine link registers. This set of register files limits the GPR
>>>> file to only 3 write ports and 18 read ports to support all the
>>>> functional units. Currently the register file is 10r2w.
>>>
>>>> The trade-off is block RAM usage instead of LUTs.
>>>
>>>> While having separate registers files seems like a step backwards,
>>>> it should ultimately make the hardware more resource efficient. It
>>>> does impact the ISA spec.
>
>> Still digesting the PRF diagram.
>
> The diagram is for a 6R6W PRF with a history table, ARN->PRN translation,
> Free pool pickers, and register ports. The X with a ½ box is a latch
> or flip-flop depending on the clocking that is put around the figure.
> It also includes the renamer {history table and free pool pickers}.
>
I note the register file on the diagram is labelled [0:64?]. 
Each register is 64-bits tall; so that should be 0:63
but each register contains an exception bit (for a variety of sanity checking
and exception handling purposes)

There are also six result / operand bits for the aRN shown feeding into the CAM. 
1 aRN for each source register in the instructions being decoded.

I figure the aRN would be only five bits.
six 5-bit sRNs.
The operand aRNs are sent through the CAM in clock high, for match detect.
Matching aRNs read the register when the clock is low.
Also, while the clock is low, destination aRNs are driven into the CAM and
if the instruction delivers a register result, the CAM entry selected by the
picker off the free list determines which CAM is allocated to that aRN, and
\any matching aRN becomes invalid.

The CAM part has me a bit confused. I think an aRN to pRN would simply
be a map (alias table), not a CAM.
aRN to unary pRN is done with a 5-bit can and a 1-bit valid, the unary
(1 of 128) is encoded in the pRN decoder to a 7-bit prn. The "tags"
running the result bus and operand forwarding is 8-bits to allow for
situations where there is no pRN assigned but there is at least 1
reservation station waiting on this result.

Before we get to the blocks::
This is designed for an execution window with 4-pointers
insert is where we insert decoded instructions into reservation stations
backup the the pointer we back up to on mispredict repair
consistent is when all instructions in a packet have been peformed and
     no exceptions have been raised
retire is when all instructions have been performed and all state has
     been updated (and all resources return from execution)

So, startnig at the top:: for the instructions being decoded::

The history table contains either::
a) a 128-bit vector of registers to be put on the free list when this packet of
instructions retire,
but more likely
b) two 128-bit vectors, one used to deliver registers back to the free list 
    the other used to recover the valid bits if/when mispredict repair is needed.
    {{while you CAN determine both 128-bit vectors from the array of 128-bit
    vectors in the history table, it is easier to just store that data.}}
During clock high the current CAM valid bits are written into the history
table, this may (or may not) be accompanied by a vector of pRNs that
become invalid (cannot ever be read again if this packet of instructions
retires--the is the deferred free list)

Below the history table is the free list, new entries fed from the history table.
The 128-bit free list is chopped into 6 sections of 22 (or 21)-bits each.
Each section has a single Find First and the find first indicates that this
is the physical register being allocated to this decode[slot] on this cycle.

Below the free list and pickers is the aRN CAM. During clock high, source
(operand) aRNs are driven in and matched, matching entries are read out
of register storage during clock low. No FF1 is required because only one
aRN->pRN mapping is valid at any instant.

During clock low, destination aRNs are driven into the CAM and a select
line from the pickers are used to modify the aRN->pRN map, at the same
time any CAM matching this aRN invalidates itself.

For the instructions delivering a result::
There is a pipeline sequence on the result bus::
a) in cycle t (tag = pRN) the tag is broadcast so the reservation stations can 
prepare to capture operand data on the forwarding path.
b) in cycle d (data = t+1) the data is driven on the result bus and 
    captured in each reservation station entry matching the pRN
c) in cycle e (exception = d+1) and recipients discard incorrectly captured
    data. If no exception: data is written into the pRF[pRN]

It is this exception bit that make bit[64] in RF section.

The symbol |X| is a latch of flip-flop depending on your pipeline timing.

Mispredict repair::
Reservation station selects a branch (BC, CALL, RET, Switch) that will
execute on the following cycle in cycle rs.
During cycle rs+1 the FU decides if the prediction was OK or not and
reads out the history of the branch of cycle[rs]. So, now, if a mispredict
is detected, we have the CAM bits to reset the aRN CAM to where it 
was before that branch was inserted into execution.
So, on cycle rs+2 we can read aRN of the old map and be decoding 
instructions from the alternate path (0-cycle repair--1 better than the
0-cycle repair of BOOM RISC-V)

Zero cycle recovery::
You read the ICache during clock high for predicted path instructions
and read the ICache during clock low for alternate path instructions.
Alternate path instructions are put in a 18-entry alternate path buffer
so that when you mispredict, you have instructions from the alternate
path ready to decode and insert.
You read out these alternate path instructions the cycle you are deciding
if the branch was mispredicted (or not)

Size considerations:
A pRF needs to capture all aRF and enough dynamic pRF to efficiently
run the instructions OoO. Generally this is aRF+checkpoints×inst/cycle.

I segmented the RF ports to support the various (6) Function Units
and used 2 copies of the pRF::

Inline image


Both my base architecture contains 32 architectural registers, and
supports 16 checkpoints of (up to) 6 instructions each; 16×6 = 96.
32+96 = 128 so the pRF has 128-entries*. The CAM will always have
32-valid-bits set, the difference between successive history table
entries will have no more than 6-bits of difference (and this is how
you can avoid the second 128-bit vector) and it is exactly these bits
that are delivered to the free list.
(*)There may be reason to make it 132-entries so the 6 pickers all
have a 22 register local free list.

>> Decided to go with a unified register file, 27r3w so far. Having
>> separate register files would not reduce the number of read ports
>> required and would add complexity to the processor.
>
> 9 Reads per 1 write ?!?!?
>
>> Loads, FPU operations and flow control (FCU) operations all share the
>> third write port of the register file. The other two write ports are
>> dedicated to the ALU results. I think this will be okay given <1% of
>> instructions would be FCU updates. Loads are about 25%, and FPU
>> depends on the application.
>
>> The ALUs/FPU/Loads have five input operands including the 3 source
>> operands, a target operand, and a mask register. Stores do not need a
>> target operand. FCU ops are non-masked so do not need a mask register
>> or target operand input.
>
>> Not planning to implement the vector register file as it would be
>> immense.